!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("fast-equals"),require("underscore"),require("react-dom"),require("idb-keyval"),require("lodash/transform"),require("react")):"function"==typeof define&&define.amd?define(["fast-equals","underscore","react-dom","idb-keyval","lodash/transform","react"],t):"object"==typeof exports?exports["react-native-onyx/web"]=t(require("fast-equals"),require("underscore"),require("react-dom"),require("idb-keyval"),require("lodash/transform"),require("react")):e["react-native-onyx/web"]=t(e["fast-equals"],e.underscore,e["react-dom"],e["idb-keyval"],e["lodash/transform"],e.react)}(self,((e,t,n,s,r,i)=>(()=>{var o={378:(e,t,n)=>{"use strict";function s(e){return e}function r(){}function i(){}function o(){}n.r(t),n.d(t,{decorateWithMetrics:()=>s,getMetrics:()=>r,printMetrics:()=>i,resetMetrics:()=>o})},703:(e,t,n)=>{"use strict";var s=n(414);function r(){}function i(){}i.resetWarningCache=r,e.exports=function(){function e(e,t,n,r,i,o){if(o!==s){var a=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw a.name="Invariant Violation",a}}function t(){return e}e.isRequired=e;var n={array:e,bool:e,func:e,number:e,object:e,string:e,symbol:e,any:e,arrayOf:t,element:e,elementType:e,instanceOf:t,node:e,objectOf:t,oneOf:t,oneOfType:t,shape:t,exact:t,checkPropTypes:i,resetWarningCache:r};return n.PropTypes=n,n}},697:(e,t,n)=>{e.exports=n(703)()},414:e=>{"use strict";e.exports="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"},746:t=>{"use strict";t.exports=e},802:e=>{"use strict";e.exports=s},407:e=>{"use strict";e.exports=r},156:e=>{"use strict";e.exports=i},111:e=>{"use strict";e.exports=n},952:e=>{"use strict";e.exports=t}},a={};function c(e){var t=a[e];if(void 0!==t)return t.exports;var n=a[e]={exports:{}};return o[e](n,n.exports,c),n.exports}c.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return c.d(t,{a:t}),t},c.d=(e,t)=>{for(var n in t)c.o(t,n)&&!c.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},c.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),c.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),c.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var l={};return(()=>{"use strict";c.r(l),c.d(l,{default:()=>Xe,withOnyx:()=>He});var e=c(746),t=c(952),n=c.n(t);let s=()=>{};function r(e){s({message:`[Onyx] ${e}`,level:"alert"})}function i(e){s({message:`[Onyx] ${e}`,level:"info"})}function o(e){return null!=e&&"object"==typeof e&&"[object RegExp]"!==Object.prototype.toString.call(e)&&"[object Date]"!==Object.prototype.toString.call(e)&&!Array.isArray(e)}function a(e,t){let s=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return n().isArray(t)||null==t?t:function(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const s={};if(o(e)){const r=Object.keys(e);for(let i=0;i<r.length;++i){const o=r[i],a=null===e[o]||null===t[o];n&&a||(s[o]=e[o])}}const r=Object.keys(t);for(let i=0;i<r.length;++i){const c=r[i],l=n&&null===t[c];if(void 0!==t[c]&&!l){const r=o(t[c]);r&&e[c]?n&&!r||(s[c]=a(e[c],t[c],n)):n&&null===t[c]||(s[c]=t[c])}}return s}(e,t,s)}const u={areObjectsEmpty:function(e,t){return"object"==typeof e&&"object"==typeof t&&n().isEmpty(e)&&n().isEmpty(t)},fastMerge:a,removeNestedNullValues:function(e){return"object"!=typeof e||n().isArray(e)?e:a(e,e)}},y=n().negate(n().isUndefined),h=new class{constructor(){this.storageKeys=new Set,this.recentKeys=new Set,this.storageMap={},this.pendingPromises=new Map,n().bindAll(this,"getAllKeys","getValue","hasCacheForKey","addKey","set","drop","merge","hasPendingTask","getTaskPromise","captureTask","removeLeastRecentlyUsedKeys","setRecentKeysLimit")}getAllKeys(){return Array.from(this.storageKeys)}getValue(e){return this.addToAccessedKeys(e),this.storageMap[e]}hasCacheForKey(e){return y(this.storageMap[e])}addKey(e){this.storageKeys.add(e)}set(e,t){return this.addKey(e),this.addToAccessedKeys(e),this.storageMap[e]=t,t}drop(e){delete this.storageMap[e],this.storageKeys.delete(e),this.recentKeys.delete(e)}merge(e){if(!n().isObject(e)||n().isArray(e))throw new Error("data passed to cache.merge() must be an Object of onyx key/value pairs");this.storageMap=Object.assign({},u.fastMerge(this.storageMap,e,!1));const t=this.getAllKeys(),s=n().keys(e);this.storageKeys=new Set([...t,...s]),n().each(s,(e=>this.addToAccessedKeys(e)))}hasPendingTask(e){return y(this.pendingPromises.get(e))}getTaskPromise(e){return this.pendingPromises.get(e)}captureTask(e,t){const n=t.finally((()=>{this.pendingPromises.delete(e)}));return this.pendingPromises.set(e,n),n}addToAccessedKeys(e){this.recentKeys.delete(e),this.recentKeys.add(e)}removeLeastRecentlyUsedKeys(){let e=this.recentKeys.size-this.maxRecentKeysSize;if(e<=0)return;const t=this.recentKeys.values(),n=[];for(;e>0;){const s=t.next().value;n.push(s),e--}for(let e=0;e<n.length;++e)delete this.storageMap[n[e]],this.recentKeys.delete(n[e])}setRecentKeysLimit(e){this.maxRecentKeysSize=e}hasValueChanged(t,n){return!(0,e.deepEqual)(this.storageMap[t],n)}};function d(e,t){return n().isString(e)&&n().isString(t)&&e.startsWith(t)}function f(e){for(var t=arguments.length,s=new Array(t>1?t-1:0),r=1;r<t;r++)s[r-1]=arguments[r];return n().isFunction(e)?e(...s):e}var p=c(407),m=c.n(p);let g=!1;function v(e){g=e}function k(e,t,s,r,i){if(!g)return;const o={};i&&(o.keyThatChanged=i),n().isObject(s)&&n().isObject(t)?o.difference=function e(t,s){return m()(t,((t,r,i)=>{n().isEqual(r,s[i])||(t[i]=n().isObject(r)&&n().isObject(s[i])?e(r,s[i]):r)}))}(t,s):(o.previousValue=t,o.newValue=s),console.debug(`[Onyx-Debug] ${e.displayName} setState() called. Subscribed to key '${e.key}' (${r})`,o)}var b=c(802);let O;const w=()=>(O||(O=(0,b.createStore)("OnyxDB","keyvaluepairs")),O),S={setItem:(e,t)=>(0,b.set)(e,t,w()),multiGet:e=>(0,b.getMany)(e,w()).then((t=>n().map(t,((t,n)=>[e[n],t])))),multiMerge:e=>w()("readwrite",(t=>Promise.all(n().map(e,(e=>{let[n]=e;return(0,b.promisifyRequest)(t.get(n))}))).then((s=>{const r=n().map(e,((e,n)=>{let[r,i]=e;const o=s[n],a=u.fastMerge(o,i);return(0,b.promisifyRequest)(t.put(a,r))}));return Promise.all(r)})))),mergeItem:(e,t,n)=>S.setItem(e,n),multiSet:e=>(0,b.setMany)(e,w()),clear:()=>(0,b.clear)(w()),setMemoryOnlyKeys:()=>{},getAllKeys:()=>(0,b.keys)(w()),getItem:e=>(0,b.get)(e,w()).then((e=>void 0===e?null:e)),removeItem:e=>(0,b.del)(e,w()),removeItems:e=>(0,b.delMany)(e,w()),getDatabaseSize(){if(!window.navigator||!window.navigator.storage)throw new Error("StorageManager browser API unavailable");return window.navigator.storage.estimate().then((e=>({bytesUsed:e.usage,bytesRemaining:e.quota-e.usage}))).catch((e=>{throw new Error(`Unable to estimate web storage quota. Original error: ${e}`)}))}},E=S,x="SYNC_ONYX";function P(e){c.g.localStorage.setItem(x,e),c.g.localStorage.removeItem(x,e)}const I={...E,keepInstancesSync(e){this.setItem=(e,t)=>E.setItem(e,t).then((()=>P(e))),this.removeItem=e=>E.removeItem(e).then((()=>P(e))),this.removeItems=e=>E.removeItems(e).then((()=>{return t=e,void n().each(t,(e=>{P(e)}));var t})),this.mergeItem=(e,t,n)=>E.mergeItem(e,t,n).then((()=>P(e))),this.clear=()=>{let e;return E.getAllKeys().then((t=>{e=t})).then((()=>E.clear())).then((()=>{n().each(e,P)}))},c.g.addEventListener("storage",(t=>{if(t.key!==x||!t.newValue)return;const n=t.newValue;E.getItem(n).then((t=>e(n,t)))}))}},M=[],T=new BroadcastChannel("BROADCAST_ONYX");function C(e){T.postMessage(e)}function K(e){M.push(e),T.onmessage=e=>{M.forEach((t=>t(e)))}}const R="NEW_LEADER",j="REMOVE_LEADER",A=function(){function e(){return Math.floor(65536*(1+Math.random())).toString(16).substring(1)}return`${arguments.length>0&&void 0!==arguments[0]?arguments[0]:""}${e()}${e()}-${e()}-${e()}-${e()}-${e()}${e()}${e()}`}(),N=[];let L=null,D=null,$=()=>{};const U=new Promise((e=>{$=e}));function _(){return U}function W(){return D===A}const q=c(111).unstable_batchedUpdates,V={SET:"set",MERGE:"merge",MERGE_COLLECTION:"mergecollection",MULTI_SET:"multiset",CLEAR:"clear"},F="on_clear",B={},G={};let z=0;const Y={};let H=new Map,X=[],Q=[];const J={};let Z={};const ee=function(){const e={};return e.promise=new Promise((t=>{e.resolve=t})),e}();let te=!1,ne=null,se=null,re=[];function ie(){return se||(se=new Promise((e=>{setTimeout((()=>{const t=re;re=[],se=null,q((()=>{t.forEach((e=>{e()}))})),e()}),0)})),se)}function oe(e){return re.push(e),ie()}const ae=(e,t,n)=>t(e,n),ce=(e,t,s)=>n().reduce(e,((e,n,r)=>(e[r]=ae(n,t,s),e)),{});function le(e){if(h.hasCacheForKey(e))return Promise.resolve(h.getValue(e));const t=`get:${e}`;if(h.hasPendingTask(t))return h.getTaskPromise(t);const n=I.getItem(e).then((t=>(h.set(e,t),t))).catch((t=>i(`Unable to get item from persistent storage. Key: ${e} Error: ${t}`)));return h.captureTask(t,n)}function ue(){const e=h.getAllKeys();if(e.length>0)return Promise.resolve(e);const t="getAllKeys";if(h.hasPendingTask(t))return h.getTaskPromise(t);const s=I.getAllKeys().then((e=>(n().each(e,(e=>h.addKey(e))),e)));return h.captureTask(t,s)}function ye(e){return H.has(e)}function he(e,t){return d(t,e)&&t.length>e.length}function de(e,t){return ye(e)?d(t,e):e===t}function fe(e){return n().some(Q,(t=>de(t,e)))}function pe(e){X=n().without(X,e)}function me(e){!ye(e)&&fe(e)&&(pe(e),X.push(e))}function ge(e,t){J[e]=n().without(J[e]||[],t),0===J[e].length&&delete J[e]}function ve(e){const t=n().filter(h.getAllKeys(),(t=>he(e,t)));return n().reduce(t,((e,t)=>{const n=h.getValue(t);return n?(e[t]=n,e):e}),{})}function ke(t,s){let r=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],i=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const o=n().keys(Y);for(let a=0;a<o.length;a++){const c=Y[o[a]];if(!c)continue;if(!d(c.key,t))continue;const l=c.key===t,y=he(t,c.key),h=ve(t);if(n().isFunction(c.callback)){if(!r)continue;if(l){if(c.waitForCollectionCallback){c.callback(h);continue}const e=n().keys(s);for(let t=0;t<e.length;t++){const n=e[t];c.callback(h[n],n)}continue}if(y){c.callback(h[c.key],c.key);continue}}else if(c.withOnyxInstance){if(!i)continue;if(l){if(c.selector){c.withOnyxInstance.setStateProxy((t=>{const n=t[c.statePropertyName],s=ce(h,c.selector,c.withOnyxInstance.state);return(0,e.deepEqual)(n,s)?null:{[c.statePropertyName]:s}}));continue}c.withOnyxInstance.setStateProxy((e=>{const r=n().clone(e[c.statePropertyName]||{}),i=n().keys(s);for(let e=0;e<i.length;e++){const t=i[e];r[t]=h[t]}return k(c,e[c.statePropertyName],r,"keysChanged",t),{[c.statePropertyName]:r}}));continue}if(y){const r=s[c.key];if(n().isUndefined(r))continue;if(c.selector){c.withOnyxInstance.setStateProxy((n=>{const s=n[c.statePropertyName],r=ae(h[c.key],c.selector,c.withOnyxInstance.state);return(0,e.deepEqual)(s,r)?null:(k(c,s,r,"keysChanged",t),{[c.statePropertyName]:r})}));continue}c.withOnyxInstance.setStateProxy((e=>{const n=h[c.key],s=e[c.statePropertyName];return u.areObjectsEmpty(n,s)||n===s?null:(k(c,s,n,"keysChanged",t),{[c.statePropertyName]:n})}))}}}}function be(t,s,r){let i=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];n().isNull(s)?pe(t):me(t);const a=n().keys(Y);for(let c=0;c<a.length;c++){const l=Y[a[c]];if(l&&de(l.key,t)&&(!n().isFunction(r)||r(l)))if(n().isFunction(l.callback)){if(!i)continue;if(ye(l.key)&&l.waitForCollectionCallback){const e=ve(l.key);e[t]=s,l.callback(e);continue}l.callback(s,t)}else if(l.withOnyxInstance){if(!o)continue;if(ye(l.key)){if(l.selector){l.withOnyxInstance.setStateProxy((n=>{const r=n[l.statePropertyName],i={[t]:ae(s,l.selector,l.withOnyxInstance.state)},o={...r,...i};return(0,e.deepEqual)(r,o)?null:(k(l,r,i,"keyChanged",t),{[l.statePropertyName]:o})}));continue}l.withOnyxInstance.setStateProxy((e=>{const n=e[l.statePropertyName]||{},r={...n,[t]:s};return k(l,n,r,"keyChanged",t),{[l.statePropertyName]:r}}));continue}if(l.selector){l.withOnyxInstance.setStateProxy((t=>{const n=ae(t[l.statePropertyName],l.selector,l.withOnyxInstance.state),r=ae(s,l.selector,l.withOnyxInstance.state);return(0,e.deepEqual)(n,r)?null:{[l.statePropertyName]:r}}));continue}l.withOnyxInstance.setStateProxy((e=>{const n=e[l.statePropertyName];return u.areObjectsEmpty(s,n)||n===s?null:(k(l,n,s,"keyChanged",t),{[l.statePropertyName]:s})}))}else console.error("Warning: Found a matching subscriber to a key that changed, but no callback or withOnyxInstance could be found.")}}function Oe(e,t,s,r){if(Y[e.connectionID]){if(e.withOnyxInstance){let n=t;return e.selector&&(n=ye(e.key)?ce(t,e.selector,e.withOnyxInstance.state):ae(t,e.selector,e.withOnyxInstance.state)),k(e,null,n,"sendDataToConnection"),void(r?oe((()=>{e.withOnyxInstance.setWithOnyxState(e.statePropertyName,n)})):e.withOnyxInstance.setWithOnyxState(e.statePropertyName,n))}n().isFunction(e.callback)&&e.callback(t,s)}}function we(e,t){Promise.all(n().map(e,(e=>le(e)))).then((t=>n().reduce(t,((t,n,s)=>(t[e[s]]=n,t)),{}))).then((e=>Oe(t,e,void 0,!0)))}function Se(e,t,n){const s=Promise.resolve().then((()=>be(e,t,n,!0,!1)));return oe((()=>be(e,t,n,!1,!0))),Promise.all([ie(),s])}function Ee(e,t){const n=Promise.resolve().then((()=>ke(e,t,!0,!1)));return oe((()=>ke(e,t,!1,!0))),Promise.all([ie(),n])}function xe(e){return h.drop(e),Se(e,null),I.removeItem(e)}function Pe(){return I.getDatabaseSize().then((e=>{let{bytesUsed:t,bytesRemaining:n}=e;i(`Storage Quota Check -- bytesUsed: ${t} bytesRemaining: ${n}`)})).catch((e=>{r(`Unable to get database size. Error: ${e}`)}))}function Ie(e,t){for(var s=arguments.length,o=new Array(s>2?s-2:0),a=2;a<s;a++)o[a-2]=arguments[a];if(i(`Failed to save to storage. Error: ${e}. onyxMethod: ${t.name}`),e&&d(e.message,"Failed to execute 'put' on 'IDBObjectStore'"))throw r("Attempted to set invalid data set in Onyx. Please ensure all data is serializable."),e;const c=n().find(X,(e=>!J[e]));return c?(i(`Out of storage. Evicting least recently accessed key (${c}) and retrying.`),Pe(),xe(c).then((()=>t(...o)))):(r("Out of storage. But found no acceptable keys to remove."),Pe())}function Me(e,t,s,r){let o=arguments.length>4&&void 0!==arguments[4]&&arguments[4];return i(`${s}() called for key: ${e}${n().isObject(t)?` properties: ${n().keys(t).join(",")}`:""}`),r&&!o?h.set(e,t):h.addToAccessedKeys(e),Se(e,t,(e=>r||!1===e.initWithStoredValues))}function Te(e){return Boolean(B[e])}function Ce(e,t){return n().isNull(t)?(xe(e),{value:t,wasRemoved:!0}):{value:u.removeNestedNullValues(t),wasRemoved:!1}}function Ke(e,t){if(!W())return C({type:V.SET,key:e,value:t}),Promise.resolve();if(te)return Promise.resolve();const{value:n,wasRemoved:s}=Ce(e,t);Te(e)&&delete B[e];const r=h.hasValueChanged(e,n),i=Me(e,n,"set",r,s);return!r||s?i:I.setItem(e,n).catch((t=>Ie(t,Ke,e,n))).then((()=>i))}function Re(e){const t=[];return n().forEach(e,((e,n)=>{const{value:s,wasRemoved:r}=Ce(n,e);r||t.push([n,s])})),t}function je(e){if(!W())return C({type:V.MULTI_SET,data:e}),Promise.resolve();if(te)return Promise.resolve();const t=Re(e),s=n().map(t,(e=>{let[t,n]=e;return h.set(t,n),Se(t,n)}));return I.multiSet(t).catch((t=>Ie(t,je,e))).then((()=>Promise.all(s)))}function Ae(e,t,s){const r=n().last(t);return n().isArray(r)?r:n().some(t,n().isObject)?n().reduce(t,((e,t)=>u.fastMerge(e,t,s)),e||{}):r}function Ne(e,t){return W()?te?Promise.resolve():n().isUndefined(t)?B[e]?G[e]:Promise.resolve():B[e]?(B[e].push(t),G[e]):(B[e]=[t],G[e]=le(e).then((t=>{if(null!=B[e])try{let s=Ae(void 0,B[e],!1);const r=n().includes(B[e],null);delete B[e],delete G[e];const{wasRemoved:i}=Ce(e,s),o=r?s:Ae(t,[s],!0);t||(s=Ae(void 0,[s],!0));const a=h.hasValueChanged(e,o),c=Me(e,o,"merge",a,i);return!a||te||i?c:I.mergeItem(e,s,o).then((()=>c))}catch(t){return r(`An error occurred while applying merge for key: ${e}, Error: ${t}`),Promise.resolve()}})),G[e]):(C({type:V.MERGE,key:e,changes:t}),Promise.resolve())}function Le(){return I.multiGet(n().keys(Z)).then((e=>{const t=n().object(e),s=u.fastMerge(t,Z);h.merge(s),n().each(s,((e,t)=>be(t,e)))}))}function De(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return W()?te?Promise.resolve():(te=!0,ue().then((t=>{const s=[],r={},i={};n().each(t,(t=>{const o=n().contains(e,t),a=n().has(Z,t);if(!o){const e=h.getValue(t),s=n().get(Z,t,null);if(s!==e){h.set(t,s);const e=t.substring(0,t.indexOf("_")+1);e?(r[e]||(r[e]={}),r[e][t]=s):i[t]=s}}o||a||s.push(t)}));const o=[];n().each(i,((e,t)=>{o.push(Se(t,e))})),n().each(r,((e,t)=>{o.push(Ee(t,e))}));const a=n().pairs(n().omit(Z,e));return n().each(s,(e=>h.drop(e))),I.removeItems(s).then((()=>I.multiSet(a))).then((()=>(te=!1,C({type:V.CLEAR,keysToPreserve:e}),Promise.all(o))))}))):(C({type:V.CLEAR,keysToPreserve:e}),Promise.resolve())}function $e(e,t){if(!n().isObject(t)||n().isArray(t)||n().isEmpty(t))return i("mergeCollection() called with invalid or empty value. Skipping this update."),Promise.resolve();let s=!1;return n().each(t,((t,n)=>{de(e,n)||(s=!0,r(`Provided collection doesn't have all its data belonging to the same parent. CollectionKey: ${e}, DataKey: ${n}`))})),s?Promise.resolve():ue().then((s=>{const[r,i]=n().chain(t).pick(((e,t)=>!n().isNull(e)||(xe(t),!1))).keys().partition((e=>s.includes(e))).value(),o=n().pick(t,r),a=n().pick(t,i),c=Re(o),l=Re(a),u=[];c.length>0&&u.push(I.multiMerge(c)),l.length>0&&u.push(I.multiSet(l));const y=Promise.all(n().map(r,le)).then((()=>(h.merge(t),Ee(e,t))));return Promise.all(u).catch((e=>Ie(e,$e,t))).then((()=>y))}))}function Ue(e){n().each(e,(e=>{let{onyxMethod:t,key:s,value:r}=e;if(!n().contains([V.CLEAR,V.SET,V.MERGE,V.MERGE_COLLECTION,V.MULTI_SET],t))throw new Error(`Invalid onyxMethod ${t} in Onyx update.`);if(t===V.MULTI_SET){if(!n().isObject(r)||n().isArray(r)||n().isFunction(r))throw new Error("Invalid value provided in Onyx multiSet. Onyx multiSet value must be of type object.")}else if(t!==V.CLEAR&&!n().isString(s))throw new Error(`Invalid ${typeof s} key provided in Onyx update. Onyx key must be of type string.`)}));const t=[];let s=Promise.resolve();return n().each(e,(e=>{let{onyxMethod:n,key:r,value:i}=e;switch(n){case V.SET:t.push((()=>Ke(r,i)));break;case V.MERGE:t.push((()=>Ne(r,i)));break;case V.MERGE_COLLECTION:t.push((()=>$e(r,i)));break;case V.MULTI_SET:t.push((()=>je(i)));break;case V.CLEAR:s=De()}})),s.then((()=>Promise.all(n().map(t,(e=>e())))))}const _e={connect:function(e){const t=z++;return Y[t]=e,Y[t].connectionID=t,!1===e.initWithStoredValues||ee.promise.then((()=>function(e){if(fe(e.key)&&(h.removeLeastRecentlyUsedKeys(),e.withOnyxInstance&&!ye(e.key))){if(n().isUndefined(e.canEvict))throw new Error(`Cannot subscribe to safe eviction key '${e.key}' without providing a canEvict value.`);me(e.key)}}(e))).then((()=>Boolean(e.key)&&"string"==typeof e.key&&!e.key.endsWith("_")&&h.storageKeys.has(e.key)?[e.key]:ue())).then((t=>{const s=n().filter(t,(t=>de(e.key,t)));if(0===s.length)return e.key&&!ye(e.key)&&h.set(e.key,null),void Oe(e,null,void 0,!1);if(n().isFunction(e.callback)){if(ye(e.key)){if(e.waitForCollectionCallback)return void we(s,e);for(let t=0;t<s.length;t++)le(s[t]).then((n=>Oe(e,n,s[t],!0)));return}le(e.key).then((t=>Oe(e,t,e.key,!0)))}else{if(e.withOnyxInstance)return ye(e.key)?void we(s,e):void le(e.key).then((t=>Oe(e,t,e.key,!0)));console.error("Warning: Onyx.connect() was found without a callback or withOnyxInstance")}})),t},disconnect:function(e,t){Y[e]&&(t&&ge(t,e),delete Y[e])},set:Ke,multiSet:je,merge:Ne,mergeCollection:$e,update:Ue,clear:De,getAllKeys:ue,init:function(){let{keys:e={},initialKeyStates:t={},safeEvictionKeys:s=[],maxCachedKeysCount:r=1e3,captureMetrics:i=!1,shouldSyncMultipleInstances:o=Boolean(c.g.localStorage),debugSetState:a=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};K((e=>{switch(e.data.type){case R:{const t=L===e.data.timestamp,n=L>e.data.timestamp;if(W()&&(n||t&&A>e.data.clientID))return;D=e.data.clientID,N.forEach((e=>e()));break}case j:D=A,L=Date.now(),C({type:R,clientID:A,timestamp:L}),N.forEach((e=>e()))}})),D=A,L=Date.now(),C({type:R,clientID:A,timestamp:L}),$(),window.addEventListener("beforeunload",(()=>{W()&&C({type:j,clientID:A})})),_().then((()=>{W()&&K((e=>{let{data:t}=e;if(W())switch(t.type){case V.CLEAR:De(t.keysToPreserve);break;case V.SET:Ke(t.key,t.value);break;case V.MULTI_SET:je(t.key,t.value);break;case V.MERGE:Ne(t.key,t.changes);break;case F:if(!ne)break;ne()}}))})),i&&function(){const e=c(378);le=e.decorateWithMetrics(le,"Onyx:get"),Ke=e.decorateWithMetrics(Ke,"Onyx:set"),je=e.decorateWithMetrics(je,"Onyx:multiSet"),De=e.decorateWithMetrics(De,"Onyx:clear"),Ne=e.decorateWithMetrics(Ne,"Onyx:merge"),$e=e.decorateWithMetrics($e,"Onyx:mergeCollection"),ue=e.decorateWithMetrics(ue,"Onyx:getAllKeys"),Le=e.decorateWithMetrics(Le,"Onyx:defaults"),Ue=e.decorateWithMetrics(Ue,"Onyx:update"),_e.set=Ke,_e.multiSet=je,_e.clear=De,_e.merge=Ne,_e.mergeCollection=$e,_e.update=Ue,_e.getMetrics=e.getMetrics,_e.resetMetrics=e.resetMetrics,_e.printMetrics=e.printMetrics}(),a&&v(!0),r>0&&h.setRecentKeysLimit(r);const l=n().values(e.COLLECTION);H=n().reduce(l,((e,t)=>(e.set(t,!0),e)),new Map),Z=t,Q=s,Promise.all([ue().then((e=>{n().each(Q,(t=>{n().each(e,(e=>{de(t,e)&&me(e)}))}))})),Le()]).then(ee.resolve),o&&n().isFunction(I.keepInstancesSync)&&I.keepInstancesSync(((e,t)=>{h.set(e,t),be(e,t)}))},registerLogger:function(e){s=e},addToEvictionBlockList:function(e,t){ge(e,t),J[e]||(J[e]=[]),J[e].push(t)},removeFromEvictionBlockList:ge,isSafeEvictionKey:fe,METHOD:V,setMemoryOnlyKeys:function(e){I.setMemoryOnlyKeys(e),h.setRecentKeysLimit(1/0)},tryGetCachedValue:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},s=h.getValue(e);if(ye(e)){const t=h.getAllKeys();if(0===t.length)return;const r=n().filter(t,(t=>t.startsWith(e)));s=n().reduce(r,((e,t)=>{const n=h.getValue(t);return n&&(e[t]=n),e}),{})}if(t.selector){const n=t.withOnyxInstance?t.withOnyxInstance.state:void 0;return ye(e)?ce(s,t.selector,n):ae(s,t.selector,n)}return s},hasPendingMergeForKey:Te,onClear:function(e){ne=e},isClientManagerReady:_,isClientTheLeader:W,subscribeToClientChange:function(e){N.push(e)}},We=_e;var qe=c(697),Ve=c.n(qe),Fe=c(156),Be=c.n(Fe);function Ge(){return Ge=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&(e[s]=n[s])}return e},Ge.apply(this,arguments)}const ze=["initialValue","allowStaleData"],Ye=(e,t)=>n().pick(e,n().keys(t));function He(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const s=n().chain(e).omit((e=>!1===e.initWithStoredValues)).keys().value();return r=>{const i=(o=r).displayName||o.name||"Component";var o;class a extends Be().Component{constructor(r){var i,o,a;super(r),i=this,a=[],(o=function(e){var t=function(e,t){if("object"!=typeof e||null===e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var s=n.call(e,"string");if("object"!=typeof s)return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==typeof t?t:String(t)}(o="pendingSetStates"))in i?Object.defineProperty(i,o,{value:a,enumerable:!0,configurable:!0,writable:!0}):i[o]=a,this.shouldDelayUpdates=t,this.setWithOnyxState=this.setWithOnyxState.bind(this),this.flushPendingSetStates=this.flushPendingSetStates.bind(this),this.activeConnectionIDs={};const c=n().reduce(e,((e,t,n)=>{const s=f(t.key,r);let i=We.tryGetCachedValue(s,t);return!i&&t.initialValue&&(i=t.initialValue),(void 0!==i&&!We.hasPendingMergeForKey(s)||t.allowStaleData)&&(e[n]=i),e}),{});c.loading=n().size(c)<s.length,this.tempState=c,this.state=c}componentDidMount(){const t=Ye(this.state,e);n().each(e,((e,s)=>{if(n().includes(ze,s))return;const r=f(e.key,{...this.props,...t});this.connectMappingToOnyx(e,s,r)})),this.checkEvictableKeys()}componentDidUpdate(t,s){const r=s.loading&&!this.state.loading,i=Ye(this.state,e),o=Ye(s,e);n().each(e,((e,s)=>{if(n().includes(ze,s))return;const a=r?e.previousKey:f(e.key,{...t,...o}),c=f(e.key,{...this.props,...i});a!==c&&(We.disconnect(this.activeConnectionIDs[a],a),delete this.activeConnectionIDs[a],this.connectMappingToOnyx(e,s,c))})),this.checkEvictableKeys()}componentWillUnmount(){n().each(e,(t=>{const n=f(t.key,{...this.props,...Ye(this.state,e)});We.disconnect(this.activeConnectionIDs[n],n)}))}setStateProxy(e){this.shouldDelayUpdates?this.pendingSetStates.push(e):this.setState(e)}setWithOnyxState(t,r){const i=this.state[t];if(!this.state.loading||!this.tempState){if(i===r||u.areObjectsEmpty(i,r))return;return void this.setStateProxy({[t]:r})}if(this.tempState[t]=r,n().some(s,(e=>n().isUndefined(this.tempState[e]))))return;const o={...this.tempState};delete this.tempState,this.setState((t=>{const s=n().reduce(o,((s,r,i)=>{if("loading"===i)return s;const o=e[i].initialValue;return(n().isUndefined(o)||n().isUndefined(t[i])||t[i]===o)&&n().isUndefined(t[i])?s[i]=r:s[i]=t[i],s}),{});return s.loading=!1,s}))}checkEvictableKeys(){n().each(e,(e=>{if(n().isUndefined(e.canEvict))return;const t=f(e.canEvict,this.props),s=f(e.key,this.props);if(!We.isSafeEvictionKey(s))throw new Error(`canEvict can't be used on key '${s}'. This key must explicitly be flagged as safe for removal by adding it to Onyx.init({safeEvictionKeys: []}).`);t?We.removeFromEvictionBlockList(s,e.connectionID):We.addToEvictionBlockList(s,e.connectionID)}))}connectMappingToOnyx(t,n,s){e[n].previousKey=s,this.activeConnectionIDs[s]=We.connect({...t,key:s,statePropertyName:n,withOnyxInstance:this,displayName:i})}flushPendingSetStates(){this.shouldDelayUpdates&&(this.shouldDelayUpdates=!1,this.pendingSetStates.forEach((e=>{this.setState(e)})),this.pendingSetStates=[])}render(){const e=n().omit(this.props,n().isNull);if(this.state.loading)return null;let t=n().omit(this.state,"loading");return t=n().omit(t,n().isNull),Be().createElement(r,Ge({markReadyForHydration:this.flushPendingSetStates},e,t,{ref:this.props.forwardedRef}))}}return a.propTypes={forwardedRef:Ve().oneOfType([Ve().func,Ve().shape({current:Ve().object})])},a.defaultProps={forwardedRef:void 0},a.displayName=`withOnyx(${i})`,Be().forwardRef(((e,t)=>{const n=a;return Be().createElement(n,Ge({},e,{forwardedRef:t}))}))}}const Xe=We})(),l})()));
//# sourceMappingURL=web.min.js.map