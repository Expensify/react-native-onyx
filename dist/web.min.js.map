{"version":3,"file":"web.min.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,EAAQG,QAAQ,eAAgBA,QAAQ,cAAeA,QAAQ,aAAcA,QAAQ,cAAeA,QAAQ,oBAAqBA,QAAQ,UACjI,mBAAXC,QAAyBA,OAAOC,IAC9CD,OAAO,CAAC,cAAe,aAAc,YAAa,aAAc,mBAAoB,SAAUJ,GACpE,iBAAZC,QACdA,QAAQ,yBAA2BD,EAAQG,QAAQ,eAAgBA,QAAQ,cAAeA,QAAQ,aAAcA,QAAQ,cAAeA,QAAQ,oBAAqBA,QAAQ,UAE5KJ,EAAK,yBAA2BC,EAAQD,EAAK,eAAgBA,EAAiB,WAAGA,EAAK,aAAcA,EAAK,cAAeA,EAAK,oBAAqBA,EAAY,MAC/J,CATD,CASGO,MAAM,CAACC,EAAkCC,EAAkCC,EAAkCC,EAAkCC,EAAkCC,I,wCCPpL,SAASC,EAAoBC,GACzB,OAAOA,CACX,CACA,SAASC,IAAc,CACvB,SAASC,IAAgB,CACzB,SAASC,IAAgB,C,6HCEzB,IAAIC,EAAuB,EAAQ,KAEnC,SAASC,IAAiB,CAC1B,SAASC,IAA0B,CACnCA,EAAuBC,kBAAoBF,EAE3CjB,EAAOD,QAAU,WACf,SAASqB,EAAKC,EAAOC,EAAUC,EAAeC,EAAUC,EAAcC,GACpE,GAAIA,IAAWV,EAAf,CAIA,IAAIW,EAAM,IAAIC,MACZ,mLAKF,MADAD,EAAIE,KAAO,sBACLF,CAPN,CAQF,CAEA,SAASG,IACP,OAAOV,CACT,CAHAA,EAAKW,WAAaX,EAMlB,IAAIY,EAAiB,CACnBC,MAAOb,EACPc,KAAMd,EACNR,KAAMQ,EACNe,OAAQf,EACRgB,OAAQhB,EACRiB,OAAQjB,EACRkB,OAAQlB,EAERmB,IAAKnB,EACLoB,QAASV,EACTW,QAASrB,EACTsB,YAAatB,EACbuB,WAAYb,EACZc,KAAMxB,EACNyB,SAAUf,EACVgB,MAAOhB,EACPiB,UAAWjB,EACXkB,MAAOlB,EACPmB,MAAOnB,EAEPoB,eAAgBhC,EAChBC,kBAAmBF,GAKrB,OAFAe,EAAemB,UAAYnB,EAEpBA,CACT,C,gBC9CEhC,EAAOD,QAAU,EAAQ,IAAR,E,uBCNnBC,EAAOD,QAFoB,8C,uBCT3BC,EAAOD,QAAUM,C,uBCAjBL,EAAOD,QAAUS,C,uBCAjBR,EAAOD,QAAUU,C,uBCAjBT,EAAOD,QAAUW,C,uBCAjBV,EAAOD,QAAUQ,C,uBCAjBP,EAAOD,QAAUO,C,GCCb8C,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaxD,QAGrB,IAAIC,EAASoD,EAAyBE,GAAY,CAGjDvD,QAAS,CAAC,GAOX,OAHA0D,EAAoBH,GAAUtD,EAAQA,EAAOD,QAASsD,GAG/CrD,EAAOD,OACf,CCrBAsD,EAAoBK,EAAK1D,IACxB,IAAI2D,EAAS3D,GAAUA,EAAO4D,WAC7B,IAAO5D,EAAiB,QACxB,IAAM,EAEP,OADAqD,EAAoBQ,EAAEF,EAAQ,CAAEG,EAAGH,IAC5BA,CAAM,ECLdN,EAAoBQ,EAAI,CAAC9D,EAASgE,KACjC,IAAI,IAAIC,KAAOD,EACXV,EAAoBY,EAAEF,EAAYC,KAASX,EAAoBY,EAAElE,EAASiE,IAC5EE,OAAOC,eAAepE,EAASiE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDX,EAAoBiB,EAAI,WACvB,GAA0B,iBAAfC,WAAyB,OAAOA,WAC3C,IACC,OAAOC,MAAQ,IAAIC,SAAS,cAAb,EAChB,CAAE,MAAOC,GACR,GAAsB,iBAAXC,OAAqB,OAAOA,MACxC,CACA,CAPuB,GCAxBtB,EAAoBY,EAAI,CAACW,EAAKC,IAAUX,OAAOY,UAAUC,eAAeC,KAAKJ,EAAKC,GCClFxB,EAAoB4B,EAAKlF,IACH,oBAAXmF,QAA0BA,OAAOC,aAC1CjB,OAAOC,eAAepE,EAASmF,OAAOC,YAAa,CAAEC,MAAO,WAE7DlB,OAAOC,eAAepE,EAAS,aAAc,CAAEqF,OAAO,GAAO,E,gHCJ9D,IAAIC,EAASA,OAgBb,SAASC,EAASC,GACdF,EAAO,CAACE,QAAU,UAASA,IAAWC,MAAO,SACjD,CAOA,SAASC,EAAQF,GACbF,EAAO,CAACE,QAAU,UAASA,IAAWC,MAAO,QACjD,CChBA,SAASE,EAAkBC,GAEvB,OAD6B,MAAPA,GAA6B,iBAARA,GAGC,oBAAxCzB,OAAOY,UAAUc,SAASZ,KAAKW,IACS,kBAAxCzB,OAAOY,UAAUc,SAASZ,KAAKW,KAE9BE,MAAMC,QAAQH,EAEvB,CAoEA,SAASI,EAAUC,EAAQC,GAA8C,IAAtCC,IAA4BC,UAAAC,OAAA,QAAA5C,IAAA2C,UAAA,KAAAA,UAAA,GAI3D,OAAIE,IAAAA,QAAUJ,IAAVI,MAAqBJ,EACdA,EAjEf,SAAqBD,EAAQC,GAA8C,IAAtCC,IAA4BC,UAAAC,OAAA,QAAA5C,IAAA2C,UAAA,KAAAA,UAAA,GAC7D,MAAMG,EAAc,CAAC,EACrB,GAAIZ,EAAkBM,GAAS,CAG3B,MAAMO,EAAarC,OAAOsC,KAAKR,GAC/B,IAAK,IAAIS,EAAI,EAAGA,EAAIF,EAAWH,SAAUK,EAAG,CACxC,MAAMzC,EAAMuC,EAAWE,GAGjBC,EAAuC,OAAhBV,EAAOhC,IAAiC,OAAhBiC,EAAOjC,GAChCkC,GAAgCQ,IAGxDJ,EAAYtC,GAAOgC,EAAOhC,GAElC,CACJ,CAIA,MAAM2C,EAAazC,OAAOsC,KAAKP,GAC/B,IAAK,IAAIQ,EAAI,EAAGA,EAAIE,EAAWP,SAAUK,EAAG,CACxC,MAAMzC,EAAM2C,EAAWF,GAGjBG,EAAsBV,GAAgD,OAAhBD,EAAOjC,GAKnE,QAF6CR,IAAhByC,EAAOjC,KAEN4C,EAAqB,CAC/C,MAAMC,EAAsBnB,EAAkBO,EAAOjC,IAEjD6C,GAAuBb,EAAOhC,GACzBkC,IAAgCW,IAEjCP,EAAYtC,GAAO+B,EAAUC,EAAOhC,GAAMiC,EAAOjC,GAAMkC,IAEnDA,GAAgD,OAAhBD,EAAOjC,KAC/CsC,EAAYtC,GAAOiC,EAAOjC,GAElC,CACJ,CAEA,OAAOsC,CACX,CAqBWQ,CAAYd,EAAQC,EAAQC,EACvC,CAUA,SAAgBa,gBAzGhB,SAAyBjD,EAAGkD,GACxB,MAAoB,iBAANlD,GAA+B,iBAANkD,GAAkBX,IAAAA,QAAUvC,IAAMuC,IAAAA,QAAUW,EACvF,EAuGiCjB,YAAWkB,uBAR5C,SAAgC7B,GAC5B,MAAqB,iBAAVA,GAAuBiB,IAAAA,QAAUjB,GAIrCA,EAHIW,EAAUX,EAAOA,EAIhC,GCrGM8B,EAAYb,IAAAA,OAASA,IAAAA,aAoO3B,EAFiB,IA5NjB,MACIc,cAMI3C,KAAK4C,YAAc,IAAIC,IAOvB7C,KAAK8C,WAAa,IAAID,IAOtB7C,KAAK+C,WAAa,CAAC,EASnB/C,KAAKgD,gBAAkB,IAAIC,IAG3BpB,IAAAA,QACI7B,KACA,aACA,WACA,iBACA,SACA,MACA,OACA,QACA,iBACA,iBACA,cACA,8BACA,qBAER,CAMAkD,aACI,OAAO7B,MAAM8B,KAAKnD,KAAK4C,YAC3B,CAOAQ,SAAS5D,GAEL,OADAQ,KAAKqD,kBAAkB7D,GAChBQ,KAAK+C,WAAWvD,EAC3B,CAOA8D,eAAe9D,GACX,OAAOkD,EAAU1C,KAAK+C,WAAWvD,GACrC,CAOA+D,OAAO/D,GACHQ,KAAK4C,YAAYY,IAAIhE,EACzB,CASAiE,IAAIjE,EAAKoB,GAKL,OAJAZ,KAAKuD,OAAO/D,GACZQ,KAAKqD,kBAAkB7D,GACvBQ,KAAK+C,WAAWvD,GAAOoB,EAEhBA,CACX,CAMA8C,KAAKlE,UACMQ,KAAK+C,WAAWvD,GACvBQ,KAAK4C,YAAYe,OAAOnE,GACxBQ,KAAK8C,WAAWa,OAAOnE,EAC3B,CAMAoE,MAAMC,GACF,IAAKhC,IAAAA,SAAWgC,IAAShC,IAAAA,QAAUgC,GAC/B,MAAM,IAAIzG,MAAM,0EAKpB4C,KAAK+C,WAAarD,OAAOoE,OAAO,CAAC,EAAGC,EAAMxC,UAAUvB,KAAK+C,WAAYc,GAAM,IAE3E,MAAMjB,EAAc5C,KAAKkD,aACnBc,EAAanC,IAAAA,KAAOgC,GAC1B7D,KAAK4C,YAAc,IAAIC,IAAI,IAAID,KAAgBoB,IAC/CnC,IAAAA,KAAOmC,GAAaxE,GAAQQ,KAAKqD,kBAAkB7D,IACvD,CAOAyE,eAAeC,GACX,OAAOxB,EAAU1C,KAAKgD,gBAAgBnD,IAAIqE,GAC9C,CAUAC,eAAeD,GACX,OAAOlE,KAAKgD,gBAAgBnD,IAAIqE,EACpC,CAUAE,YAAYF,EAAUG,GAClB,MAAMC,EAAgBD,EAAQE,SAAQ,KAClCvE,KAAKgD,gBAAgBW,OAAOO,EAAS,IAKzC,OAFAlE,KAAKgD,gBAAgBS,IAAIS,EAAUI,GAE5BA,CACX,CAOAjB,kBAAkB7D,GAEdQ,KAAK8C,WAAWa,OAAOnE,GACvBQ,KAAK8C,WAAWU,IAAIhE,EACxB,CAKAgF,8BACI,IAAIC,EAAkBzE,KAAK8C,WAAW4B,KAAO1E,KAAK2E,kBAClD,GAAIF,GAAmB,EACnB,OAEJ,MAAMG,EAAW5E,KAAK8C,WAAW+B,SAC3BC,EAAO,GACb,KAAOL,EAAkB,GAAG,CACxB,MAAM7D,EAAQgE,EAASG,OAAOnE,MAC9BkE,EAAKE,KAAKpE,GACV6D,GACJ,CAEA,IAAK,IAAIxC,EAAI,EAAGA,EAAI6C,EAAKlD,SAAUK,SACxBjC,KAAK+C,WAAW+B,EAAK7C,IAC5BjC,KAAK8C,WAAWa,OAAOmB,EAAK7C,GAEpC,CAMAgD,mBAAmBC,GACflF,KAAK2E,kBAAoBO,CAC7B,CAOAC,gBAAgB3F,EAAKoB,GACjB,QAAQwE,EAAAA,EAAAA,WAAUpF,KAAK+C,WAAWvD,GAAMoB,EAC5C,GC1NJ,SAASyE,EAAWC,EAAUC,GAC1B,OAAO1D,IAAAA,SAAWyD,IAAazD,IAAAA,SAAW0D,IAAWD,EAASD,WAAWE,EAC7E,CAWA,SAASC,EAAOC,GAAqB,IAAD,IAAAC,EAAA/D,UAAAC,OAAN+D,EAAI,IAAAtE,MAAAqE,EAAA,EAAAA,EAAA,KAAAE,EAAA,EAAAA,EAAAF,EAAAE,IAAJD,EAAIC,EAAA,GAAAjE,UAAAiE,GAC9B,OAAO/D,IAAAA,WAAa4D,GAAaA,KAAaE,GAAQF,CAC1D,C,sBCrBA,IAAII,GAAgB,EAKpB,SAASC,EAAuBC,GAC5BF,EAAgBE,CACpB,CAiCA,SAASC,EAAgBC,EAASC,EAAeC,EAAUC,EAAQC,GAC/D,IAAKR,EACD,OAGJ,MAAMS,EAAY,CAAC,EACfD,IACAC,EAAUD,eAAiBA,GAE3BxE,IAAAA,SAAWsE,IAAatE,IAAAA,SAAWqE,GACnCI,EAAUC,WAhCd,SAASC,EAAQpG,EAAKqG,GAClB,OAAOC,IAAgBtG,GAAK,CAACoF,EAAQ5E,EAAOpB,KACpCqC,IAAAA,QAAUjB,EAAO6F,EAAiBjH,MAKtCgG,EAAOhG,GAAOqC,IAAAA,SAAWjB,IAAUiB,IAAAA,SAAW4E,EAAiBjH,IAAQgH,EAAQ5F,EAAO6F,EAAiBjH,IAAQoB,EAAK,GAE5H,CACO4F,CAsB+BN,EAAeC,IAEjDG,EAAUJ,cAAgBA,EAC1BI,EAAUH,SAAWA,GAGzBQ,QAAQZ,MAAO,gBAAeE,EAAQW,qDAAqDX,EAAQzG,SAAS4G,KAAWE,EAC3H,C,aCtDA,IAAIO,EACJ,MAAMC,EAAiBA,KACdD,IACDA,GAAsBE,EAAAA,EAAAA,aAAY,SAAU,kBAEzCF,GAGLG,EAAW,CAObC,QAASA,CAACzH,EAAKoB,KAAU6C,EAAAA,EAAAA,KAAIjE,EAAKoB,EAAOkG,KAQzCI,SAAWC,IAAcC,EAAAA,EAAAA,SAAQD,EAAWL,KAAkBO,MAAMxC,GAAWhD,IAAAA,IAAMgD,GAAQ,CAACjE,EAAO0G,IAAU,CAACH,EAAUG,GAAQ1G,OAQlI2G,WAAaC,GACTV,IAAiB,aAAcW,GAITC,QAAQC,IAAI9F,IAAAA,IAAM2F,GAAOI,IAAA,IAAEpI,GAAIoI,EAAA,OAAKC,EAAAA,EAAAA,kBAAiBJ,EAAM5H,IAAIL,GAAK,KAErE6H,MAAMxC,IACnB,MAAMiD,EAAajG,IAAAA,IAAM2F,GAAO,CAAAO,EAAeT,KAAW,IAAxB9H,EAAKoB,GAAMmH,EACzC,MAAMC,EAAOnD,EAAOyC,GACdnB,EAAWpC,EAAMxC,UAAUyG,EAAMpH,GACvC,OAAOiH,EAAAA,EAAAA,kBAAiBJ,EAAMQ,IAAI9B,EAAU3G,GAAK,IAErD,OAAOkI,QAAQC,IAAIG,EAAW,MAW1CI,UAASA,CAAC1I,EAAK2I,EAAUC,IAEdpB,EAASC,QAAQzH,EAAK4I,GAQjCC,SAAWb,IAAUc,EAAAA,EAAAA,SAAQd,EAAOV,KAMpCyB,MAAOA,KAAMA,EAAAA,EAAAA,OAAMzB,KAGnB0B,kBAAmBA,OAMnBtF,WAAYA,KAAMlB,EAAAA,EAAAA,MAAK8E,KAOvB2B,QAAUjJ,IACNK,EAAAA,EAAAA,KAAIL,EAAKsH,KAEJO,MAAMlG,QAAiBnC,IAARmC,EAAoB,KAAOA,IAOnDuH,WAAalJ,IAAQmJ,EAAAA,EAAAA,KAAInJ,EAAKsH,KAQ9B8B,YAAczB,IAAc0B,EAAAA,EAAAA,SAAQ1B,EAAWL,KAM/CgC,kBACI,IAAK3I,OAAO4I,YAAc5I,OAAO4I,UAAUC,QACvC,MAAM,IAAI5L,MAAM,0CAGpB,OAAO+C,OAAO4I,UAAUC,QACnBC,WACA5B,MAAMzG,IAAU,CACbsI,UAAWtI,EAAMuI,MACjBC,eAAgBxI,EAAMyI,MAAQzI,EAAMuI,UAEvCG,OAAOC,IACJ,MAAM,IAAInM,MAAO,yDAAwDmM,IAAQ,GAE7F,GAGJ,IC9HMC,EAAY,YAMlB,SAASC,EAAsBC,GAC3BC,EAAAA,EAAOC,aAAa3C,QAAQuC,EAAWE,GACvCC,EAAAA,EAAOC,aAAalB,WAAWc,EAAWE,EAC9C,CAQA,MCvBA,EDuBmB,IACZG,EAKHC,kBAAkBC,GAEd/J,KAAKiH,QAAU,CAACzH,EAAKoB,IAAUiJ,EAAAA,QAAgBrK,EAAKoB,GAAOyG,MAAK,IAAMoC,EAAsBjK,KAE5FQ,KAAK0I,WAAclJ,GAAQqK,EAAAA,WAAmBrK,GAAK6H,MAAK,IAAMoC,EAAsBjK,KAEpFQ,KAAK4I,YAAe5G,GAAS6H,EAAAA,YAAoB7H,GAAMqF,MAAK,KAAM2C,OAlBnCC,EAkBiEjI,OAjBpGH,IAAAA,KAAOoI,GAAWP,IACdD,EAAsBC,EAAQ,IAFtC,IAAuCO,CAkBsE,IAErGjK,KAAKkI,UAAY,CAAC1I,EAAK0K,EAAgB9B,IAAiByB,EAAAA,UAAkBrK,EAAK0K,EAAgB9B,GAAcf,MAAK,IAAMoC,EAAsBjK,KAK9IQ,KAAKuI,MAAQ,KACT,IAAI4B,EAGJ,OAAON,EAAAA,aACFxC,MAAMrF,IACHmI,EAAUnI,CAAI,IAEjBqF,MAAK,IAAMwC,EAAAA,UACXxC,MAAK,KAGFxF,IAAAA,KAAOsI,EAASV,EAAsB,GACxC,EAIVE,EAAAA,EAAOS,iBAAiB,WAAYC,IAEhC,GAAIA,EAAM7K,MAAQgK,IAAca,EAAMlE,SAClC,OAGJ,MAAMuD,EAAUW,EAAMlE,SACtB0D,EAAAA,QAAgBH,GAASrC,MAAMzG,GAAUmJ,EAAoBL,EAAS9I,IAAO,GAErF,GEpEE0J,EAAgB,GAChBC,EAAU,IAAIC,iBAHG,kBASvB,SAASC,EAAY1J,GACjBwJ,EAAQG,YAAY3J,EACxB,CAOA,SAAS4J,EAAUC,GACfN,EAActF,KAAK4F,GACnBL,EAAQM,UAAa9J,IACjBuJ,EAAcQ,SAASC,GAAMA,EAAEhK,IAAS,CAEhD,CCdA,MAAMiK,EAAqB,aACrBC,EAAyB,gBAEzBC,ENoBN,WACI,SAASC,IACL,OAAOC,KAAKC,MAA4B,OAArB,EAAID,KAAKE,WACvBlK,SAAS,IACTmK,UAAU,EACnB,CACA,MAAQ,GANQ5J,UAAAC,OAAA,QAAA5C,IAAA2C,UAAA,GAAAA,UAAA,GAAG,KAMAwJ,MAAOA,OAAQA,OAAQA,OAAQA,OAAQA,MAAOA,MAAOA,KAC5E,CM3BiBK,GACXC,EAAc,GACpB,IAAIC,EAAY,KAEZC,EAAiB,KACjBC,EAAaA,OACjB,MAAMC,EAAiB,IAAInE,SAASoE,IAChCF,EAAaE,CAAO,IAOxB,SAASC,IACL,OAAOF,CACX,CAOA,SAASG,IACL,OAAOL,IAAmBT,CAC9B,CCnCA,Q,OAAsC,wBCahCe,EAAS,CACXC,IAAK,MACLC,MAAO,QACPC,iBAAkB,kBAClBC,UAAW,WACXC,MAAO,SAGLC,EAAW,WAGXC,EAAa,CAAC,EACdC,EAAoB,CAAC,EAG3B,IAAIC,EAAmB,EAGvB,MAAMC,EAAyB,CAAC,EAGhC,IAAIC,EAAuB,IAAI3J,IAG3B4J,EAAuB,GAIvBC,EAAoB,GAIxB,MAAMC,EAAoB,CAAC,EAG3B,IAAIC,EAAmB,CAAC,EAGxB,MAAMC,GC7CS,WACX,MAAMC,EAAW,CAAC,EAKlB,OAJAA,EAAS7I,QAAU,IAAIqD,SAASyF,IAC5BD,EAASpB,QAAUqB,CAAG,IAGnBD,CACX,CDsCyBE,GAGzB,IAAIC,IAAa,EAGbC,GAAkB,KAElBC,GAAsB,KACtBC,GAAoB,GASxB,SAASC,KACL,OAAIF,KAIJA,GAAsB,IAAI7F,SAASoE,IAK/B4B,YAAW,KACP,MAAMC,EAAcH,GACpBA,GAAoB,GACpBD,GAAsB,KACtBK,GAAwB,KACpBD,EAAY7C,SAAS+C,IACjBA,GAAc,GAChB,IAGN/B,GAAS,GACV,EAAE,IAEFyB,GACX,CAEA,SAASO,GAAaC,GAElB,OADAP,GAAkBxI,KAAK+I,GAChBN,IACX,CASA,MAAMO,GAAkBA,CAACC,EAAYC,EAAUC,IAA0BD,EAASD,EAAYE,GAWxFC,GAA+BA,CAACC,EAAYH,EAAUC,IACxDtM,IAAAA,OACIwM,GACA,CAACC,EAAiBC,EAAM/O,KAEpB8O,EAAgB9O,GAAOwO,GAAgBO,EAAML,EAAUC,GAEhDG,IAEX,CAAC,GAUT,SAASzO,GAAIL,GAET,GAAIgP,EAAAA,eAAqBhP,GACrB,OAAOkI,QAAQoE,QAAQ0C,EAAAA,SAAehP,IAG1C,MAAM0E,EAAY,OAAM1E,IAGxB,GAAIgP,EAAAA,eAAqBtK,GACrB,OAAOsK,EAAAA,eAAqBtK,GAIhC,MAAMG,EAAUwF,EAAAA,QAAgBrK,GAC3B6H,MAAMlG,IACHqN,EAAAA,IAAUhP,EAAK2B,GACRA,KAEVmI,OAAOnM,GAAQsR,EAAgB,oDAAmDjP,YAAcrC,OAErG,OAAOqR,EAAAA,YAAkBtK,EAAUG,EACvC,CAOA,SAASnB,KAEL,MAAMwL,EAAaF,EAAAA,aACnB,GAAIE,EAAW9M,OAAS,EACpB,OAAO8F,QAAQoE,QAAQ4C,GAG3B,MAAMxK,EAAW,aAGjB,GAAIsK,EAAAA,eAAqBtK,GACrB,OAAOsK,EAAAA,eAAqBtK,GAIhC,MAAMG,EAAUwF,EAAAA,aAAqBxC,MAAMrF,IACvCH,IAAAA,KAAOG,GAAOxC,GAAQgP,EAAAA,OAAahP,KAC5BwC,KAGX,OAAOwM,EAAAA,YAAkBtK,EAAUG,EACvC,CAUA,SAASsK,GAAgBnP,GACrB,OAAOoN,EAAqBgC,IAAIpP,EACpC,CAOA,SAASqP,GAAsBC,EAAetP,GAC1C,OAAOgM,EAAehM,EAAKsP,IAAkBtP,EAAIoC,OAASkN,EAAclN,MAC5E,CAWA,SAASmN,GAAWC,EAAWxP,GAC3B,OAAOmP,GAAgBK,GAAaxD,EAAehM,EAAKwP,GAAaA,IAAcxP,CACvF,CAUA,SAASyP,GAAkBC,GACvB,OAAOrN,IAAAA,KAAOiL,GAAoBtN,GAAQuP,GAAWvP,EAAK0P,IAC9D,CAwDA,SAASC,GAAsB3P,GAC3BqN,EAAuBhL,IAAAA,QAAUgL,EAAsBrN,EAC3D,CAUA,SAAS4P,GAAmB5P,IAEpBmP,GAAgBnP,IAASyP,GAAkBzP,KAI/C2P,GAAsB3P,GACtBqN,EAAqB7H,KAAKxF,GAC9B,CAUA,SAAS6P,GAA4B7P,EAAK8P,GACtCvC,EAAkBvN,GAAOqC,IAAAA,QAAUkL,EAAkBvN,IAAQ,GAAI8P,GAG3B,IAAlCvC,EAAkBvN,GAAKoC,eAChBmL,EAAkBvN,EAEjC,CA8CA,SAAS+P,GAAoBT,GACzB,MAAMU,EAAuB3N,IAAAA,OAAS2M,EAAAA,cAAqBiB,GAAcZ,GAAsBC,EAAeW,KAE9G,OAAO5N,IAAAA,OACH2N,GACA,CAACxH,EAAM0H,KACH,MAAMC,EAAcnB,EAAAA,SAAekB,GACnC,OAAKC,GAKL3H,EAAK0H,GAAQC,EACN3H,GALIA,CAKA,GAEf,CAAC,EAET,CAWA,SAAS4H,GAAYd,EAAee,GAAqF,IAAlEC,IAAuBnO,UAAAC,OAAA,QAAA5C,IAAA2C,UAAA,KAAAA,UAAA,GAASoO,IAAwBpO,UAAAC,OAAA,QAAA5C,IAAA2C,UAAA,KAAAA,UAAA,GAI3G,MAAMqO,EAAmBnO,IAAAA,KAAO8K,GAChC,IAAK,IAAI1K,EAAI,EAAGA,EAAI+N,EAAiBpO,OAAQK,IAAK,CAC9C,MAAMgO,EAAatD,EAAuBqD,EAAiB/N,IAC3D,IAAKgO,EACD,SAIJ,IAAKzE,EAAeyE,EAAWzQ,IAAKsP,GAChC,SAMJ,MAAMoB,EAA8BD,EAAWzQ,MAAQsP,EAKjDqB,EAAoCtB,GAAsBC,EAAemB,EAAWzQ,KAIpF4Q,EAAmBb,GAAoBT,GAG7C,GAAIjN,IAAAA,WAAaoO,EAAWrF,UAA5B,CACI,IAAKkF,EACD,SAKJ,GAAII,EAA6B,CAC7B,GAAID,EAAWI,0BAA2B,CACtCJ,EAAWrF,SAASwF,GACpB,QACJ,CAIA,MAAME,EAAWzO,IAAAA,KAAOgO,GACxB,IAAK,IAAIU,EAAI,EAAGA,EAAID,EAAS1O,OAAQ2O,IAAK,CACtC,MAAMC,EAAUF,EAASC,GACzBN,EAAWrF,SAASwF,EAAiBI,GAAUA,EACnD,CACA,QACJ,CAIA,GAAIL,EAAmC,CACnCF,EAAWrF,SAASwF,EAAiBH,EAAWzQ,KAAMyQ,EAAWzQ,KACjE,QACJ,CAGJ,MAGA,GAAIyQ,EAAWQ,iBAAkB,CAC7B,IAAKV,EACD,SAKJ,GAAIG,EAA6B,CAG7B,GAAID,EAAW/B,SAAU,CACrB+B,EAAWQ,iBAAiBC,eAAeC,IACvC,MAAMC,EAAeD,EAAUV,EAAWY,mBACpCC,EAAU1C,GAA6BgC,EAAkBH,EAAW/B,SAAU+B,EAAWQ,iBAAiBM,OAEhH,OAAK3L,EAAAA,EAAAA,WAAUwL,EAAcE,GAKtB,KAJI,CACH,CAACb,EAAWY,mBAAoBC,EAG7B,IAEf,QACJ,CAEAb,EAAWQ,iBAAiBC,eAAeC,IACvC,MAAMrC,EAAkBzM,IAAAA,MAAQ8O,EAAUV,EAAWY,oBAAsB,CAAC,GACtEP,EAAWzO,IAAAA,KAAOgO,GACxB,IAAK,IAAIU,EAAI,EAAGA,EAAID,EAAS1O,OAAQ2O,IAAK,CACtC,MAAMC,EAAUF,EAASC,GACzBjC,EAAgBkC,GAAWJ,EAAiBI,EAChD,CAGA,OADAQ,EAAiCf,EAAYU,EAAUV,EAAWY,mBAAoBvC,EAAiB,cAAeQ,GAC/G,CACH,CAACmB,EAAWY,mBAAoBvC,EACnC,IAEL,QACJ,CAGA,GAAI6B,EAAmC,CAGnC,MAAMc,EAAqBpB,EAAkBI,EAAWzQ,KACxD,GAAIqC,IAAAA,YAAcoP,GACd,SAMJ,GAAIhB,EAAW/B,SAAU,CACrB+B,EAAWQ,iBAAiBC,eAAeC,IACvC,MAAMO,EAAWP,EAAUV,EAAWY,mBAChCC,EAAU9C,GAAgBoC,EAAiBH,EAAWzQ,KAAMyQ,EAAW/B,SAAU+B,EAAWQ,iBAAiBM,OACnH,OAAK3L,EAAAA,EAAAA,WAAU8L,EAAUJ,GAOlB,MANHE,EAAiCf,EAAYiB,EAAUJ,EAAS,cAAehC,GACxE,CACH,CAACmB,EAAWY,mBAAoBC,GAI7B,IAEf,QACJ,CAEAb,EAAWQ,iBAAiBC,eAAeC,IACvC,MAAM9M,EAAOuM,EAAiBH,EAAWzQ,KACnCoR,EAAeD,EAAUV,EAAWY,mBAG1C,OAAI9M,EAAMxB,gBAAgBsB,EAAM+M,IAG5B/M,IAAS+M,EAFF,MAMXI,EAAiCf,EAAYW,EAAc/M,EAAM,cAAeiL,GACzE,CACH,CAACmB,EAAWY,mBAAoBhN,GACnC,GAET,CACJ,CACJ,CACJ,CAeA,SAASsN,GAAW3R,EAAKqE,EAAMuN,GAAuF,IAAlEtB,IAAuBnO,UAAAC,OAAA,QAAA5C,IAAA2C,UAAA,KAAAA,UAAA,GAASoO,IAAwBpO,UAAAC,OAAA,QAAA5C,IAAA2C,UAAA,KAAAA,UAAA,GAEnGE,IAAAA,OAASgC,GAGVsL,GAAsB3P,GAFtB4P,GAAmB5P,GAQvB,MAAMwQ,EAAmBnO,IAAAA,KAAO8K,GAChC,IAAK,IAAI1K,EAAI,EAAGA,EAAI+N,EAAiBpO,OAAQK,IAAK,CAC9C,MAAMgO,EAAatD,EAAuBqD,EAAiB/N,IAC3D,GAAKgO,GAAelB,GAAWkB,EAAWzQ,IAAKA,MAASqC,IAAAA,WAAauP,IAAyBA,EAAoBnB,IAKlH,GAAIpO,IAAAA,WAAaoO,EAAWrF,UAA5B,CACI,IAAKkF,EACD,SAEJ,GAAInB,GAAgBsB,EAAWzQ,MAAQyQ,EAAWI,0BAA2B,CACzE,MAAMD,EAAmBb,GAAoBU,EAAWzQ,KACxD4Q,EAAiB5Q,GAAOqE,EACxBoM,EAAWrF,SAASwF,GACpB,QACJ,CAEAH,EAAWrF,SAAS/G,EAAMrE,EAE9B,MAGA,GAAIyQ,EAAWQ,iBAAf,CACI,IAAKV,EACD,SAIJ,GAAIpB,GAAgBsB,EAAWzQ,KAAM,CAGjC,GAAIyQ,EAAW/B,SAAU,CACrB+B,EAAWQ,iBAAiBC,eAAeC,IACvC,MAAMO,EAAWP,EAAUV,EAAWY,mBAChCC,EAAU,CACZ,CAACtR,GAAMwO,GAAgBnK,EAAMoM,EAAW/B,SAAU+B,EAAWQ,iBAAiBM,QAE5EM,EAAsB,IACrBH,KACAJ,GAEP,OAAK1L,EAAAA,EAAAA,WAAU8L,EAAUG,GAMlB,MALHL,EAAiCf,EAAYiB,EAAUJ,EAAS,aAActR,GACvE,CACH,CAACyQ,EAAWY,mBAAoBQ,GAG7B,IAEf,QACJ,CAEApB,EAAWQ,iBAAiBC,eAAeC,IACvC,MAAMtC,EAAasC,EAAUV,EAAWY,oBAAsB,CAAC,EACzDS,EAAgB,IACfjD,EACH,CAAC7O,GAAMqE,GAGX,OADAmN,EAAiCf,EAAY5B,EAAYiD,EAAe,aAAc9R,GAC/E,CACH,CAACyQ,EAAWY,mBAAoBS,EACnC,IAEL,QACJ,CAIA,GAAIrB,EAAW/B,SAAU,CACrB+B,EAAWQ,iBAAiBC,eAAeC,IACvC,MAAMzK,EAAgB8H,GAAgB2C,EAAUV,EAAWY,mBAAoBZ,EAAW/B,SAAU+B,EAAWQ,iBAAiBM,OAC1H5K,EAAW6H,GAAgBnK,EAAMoM,EAAW/B,SAAU+B,EAAWQ,iBAAiBM,OACxF,OAAK3L,EAAAA,EAAAA,WAAUc,EAAeC,GAKvB,KAJI,CACH,CAAC8J,EAAWY,mBAAoB1K,EAG7B,IAEf,QACJ,CAGA8J,EAAWQ,iBAAiBC,eAAeC,IACvC,MAAMC,EAAeD,EAAUV,EAAWY,mBAG1C,OAAI9M,EAAMxB,gBAAgBsB,EAAM+M,IAG5BA,IAAiB/M,EAFV,MAMXmN,EAAiCf,EAAYW,EAAc/M,EAAM,aAAcrE,GACxE,CACH,CAACyQ,EAAWY,mBAAoBhN,GACnC,GAGT,MAEA8C,QAAQ4C,MAAM,kHAClB,CACJ,CAiBA,SAASgI,GAAqBtL,EAAS9E,EAAKqQ,EAAYC,GAGpD,GAAK9E,EAAuB1G,EAAQqJ,cAApC,CAIA,GAAIrJ,EAAQwK,iBAAkB,CAC1B,IAAIK,EAAU3P,EAoBd,OAhBI8E,EAAQiI,WAEJ4C,EADAnC,GAAgB1I,EAAQzG,KACd4O,GAA6BjN,EAAK8E,EAAQiI,SAAUjI,EAAQwK,iBAAiBM,OAE7E/C,GAAgB7M,EAAK8E,EAAQiI,SAAUjI,EAAQwK,iBAAiBM,QAIlFC,EAAiC/K,EAAS,KAAM6K,EAAS,6BACrDW,EACA3D,IAAa,KACT7H,EAAQwK,iBAAiBiB,iBAAiBzL,EAAQ4K,kBAAmBC,EAAQ,IAGjF7K,EAAQwK,iBAAiBiB,iBAAiBzL,EAAQ4K,kBAAmBC,GAG7E,CAEIjP,IAAAA,WAAaoE,EAAQ2E,WACrB3E,EAAQ2E,SAASzJ,EAAKqQ,EA3B1B,CA6BJ,CAkCA,SAASG,GAAiCC,EAAc3L,GACpDyB,QAAQC,IAAI9F,IAAAA,IAAM+P,GAAepS,GAAQK,GAAIL,MACxC6H,MAAMxC,GACHhD,IAAAA,OACIgD,GACA,CAACgN,EAAajR,EAAOqB,KAEjB4P,EAAYD,EAAa3P,IAAMrB,EACxBiR,IAEX,CAAC,KAGRxK,MAAMlG,GAAQoQ,GAAqBtL,EAAS9E,OAAKnC,GAAW,IACrE,CAoJA,SAAS8S,GAAyBtS,EAAKoB,EAAOwQ,GAC1C,MAAM/M,EAAUqD,QAAQoE,UAAUzE,MAAK,IAAM8J,GAAW3R,EAAKoB,EAAOwQ,GAAqB,GAAM,KAE/F,OADAtD,IAAa,IAAMqD,GAAW3R,EAAKoB,EAAOwQ,GAAqB,GAAO,KAC/D1J,QAAQC,IAAI,CAAC8F,KAA0BpJ,GAClD,CAWA,SAAS0N,GAAoCvS,EAAKoB,GAC9C,MAAMyD,EAAUqD,QAAQoE,UAAUzE,MAAK,IAAMuI,GAAYpQ,EAAKoB,GAAO,GAAM,KAE3E,OADAkN,IAAa,IAAM8B,GAAYpQ,EAAKoB,GAAO,GAAO,KAC3C8G,QAAQC,IAAI,CAAC8F,KAA0BpJ,GAClD,CASA,SAAS2N,GAAOxS,GAGZ,OAFAgP,EAAAA,KAAWhP,GACXsS,GAAyBtS,EAAK,MACvBqK,EAAAA,WAAmBrK,EAC9B,CAMA,SAASyS,KACL,OAAOpI,EAAAA,kBACFxC,MAAKO,IAAkC,IAAjC,UAACsB,EAAS,eAAEE,GAAexB,EAC9B6G,EAAgB,qCAAoCvF,qBAA6BE,IAAiB,IAErGE,OAAO4I,IACJzD,EAAiB,uCAAsCyD,IAAc,GAEjF,CAaA,SAASC,GAAqB5I,EAAO6I,GAAsB,IAAD,IAAA1M,EAAA/D,UAAAC,OAAN+D,EAAI,IAAAtE,MAAAqE,EAAA,EAAAA,EAAA,KAAAE,EAAA,EAAAA,EAAAF,EAAAE,IAAJD,EAAIC,EAAA,GAAAjE,UAAAiE,GAGpD,GAFA6I,EAAgB,qCAAoClF,kBAAsB6I,EAAW/U,QAEjFkM,GAASiC,EAAejC,EAAMxI,QAAS,+CAEvC,MADA0N,EAAgB,sFACVlF,EAIV,MAAM8I,EAAgBxQ,IAAAA,KAAOgL,GAAuBrN,IAASuN,EAAkBvN,KAC/E,OAAK6S,GASL5D,EAAgB,yDAAwD4D,oBACxEJ,KACOD,GAAOK,GAAehL,MAAK,IAAM+K,KAAczM,OAPlD8I,EAAgB,2DACTwD,KAOf,CAYA,SAASK,GAAgB9S,EAAKoB,EAAO2R,EAAQC,GAAiC,IAArBC,EAAU9Q,UAAAC,OAAA,QAAA5C,IAAA2C,UAAA,IAAAA,UAAA,GAY/D,OAVA8M,EAAgB,GAAE8D,uBAA4B/S,IAAMqC,IAAAA,SAAWjB,GAAU,gBAAeiB,IAAAA,KAAOjB,GAAO8R,KAAK,OAAS,MAIhHF,IAAeC,EACfjE,EAAAA,IAAUhP,EAAKoB,GAEf4N,EAAAA,kBAAwBhP,GAGrBsS,GAAyBtS,EAAKoB,GAAQqP,GAAeuC,IAAkD,IAApCvC,EAAW0C,sBACzF,CAMA,SAASC,GAAsBpT,GAC3B,OAAOqT,QAAQrG,EAAWhN,GAC9B,CASA,SAASsT,GAAiBtT,EAAKoB,GAC3B,OAAIiB,IAAAA,OAASjB,IACToR,GAAOxS,GACA,CAACoB,QAAO6R,YAAY,IAMxB,CAAC7R,MAAOmD,EAAMtB,uBAAuB7B,GAAQ6R,YAAY,EACpE,CAUA,SAAShP,GAAIjE,EAAKoB,GACd,IAAKmS,IAED,OADAC,EAAsB,CAACC,KAAMhH,EAAOC,IAAK1M,MAAKoB,UACvC8G,QAAQoE,UAGnB,GAAIuB,GACA,OAAO3F,QAAQoE,UAInB,MAAOlL,MAAOsS,EAAkB,WAAET,GAAcK,GAAiBtT,EAAKoB,GAElEgS,GAAsBpT,WACfgN,EAAWhN,GAGtB,MAAMgT,EAAahE,EAAAA,gBAAsBhP,EAAK0T,GAGxCC,EAAgBb,GAAgB9S,EAAK0T,EAAoB,MAAOV,EAAYC,GAGlF,OAAKD,GAAcC,EACRU,EAGJtJ,EAAAA,QAAgBrK,EAAK0T,GACvB5J,OAAOC,GAAU4I,GAAqB5I,EAAO9F,GAAKjE,EAAK0T,KACvD7L,MAAK,IAAM8L,GACpB,CAUA,SAASC,GAA+BvP,GACpC,MAAMwP,EAAgB,GAUtB,OARAxR,IAAAA,QAAUgC,GAAM,CAACjD,EAAOpB,KACpB,MAAOoB,MAAOsS,EAAkB,WAAET,GAAcK,GAAiBtT,EAAKoB,GAElE6R,GAEJY,EAAcrO,KAAK,CAACxF,EAAK0T,GAAoB,IAG1CG,CACX,CAUA,SAAShL,GAASxE,GACd,IAAKkP,IAED,OADAC,EAAsB,CAACC,KAAMhH,EAAOI,UAAWxI,SACxC6D,QAAQoE,UAGnB,GAAIuB,GACA,OAAO3F,QAAQoE,UAGnB,MAAMuH,EAAgBD,GAA+BvP,GAE/CyP,EAAiBzR,IAAAA,IAAMwR,GAAetL,IAAmB,IAAjBvI,EAAKoB,GAAMmH,EAGrD,OADAyG,EAAAA,IAAUhP,EAAKoB,GACRkR,GAAyBtS,EAAKoB,EAAM,IAG/C,OAAOiJ,EAAAA,SAAiBwJ,GACnB/J,OAAOC,GAAU4I,GAAqB5I,EAAOlB,GAAUxE,KACvDwD,MAAK,IAAMK,QAAQC,IAAI2L,IAChC,CAWA,SAASC,GAAWC,EAAehN,EAAS9E,GACxC,MAAM+R,EAAa5R,IAAAA,KAAO2E,GAE1B,OAAI3E,IAAAA,QAAU4R,GACHA,EAGP5R,IAAAA,KAAO2E,EAAS3E,IAAAA,UAETA,IAAAA,OAAS2E,GAAS,CAAC4B,EAAcsL,IAAW3P,EAAMxC,UAAU6G,EAAcsL,EAAQhS,IAA+B8R,GAAiB,CAAC,GAKvIC,CACX,CAsBA,SAAS7P,GAAMpE,EAAKgH,GAChB,OAAKuM,IAKD1F,GACO3F,QAAQoE,UAKfjK,IAAAA,YAAc2E,GACPgG,EAAWhN,GAAOiN,EAAkBjN,GAAOkI,QAAQoE,UAK1DU,EAAWhN,IACXgN,EAAWhN,GAAKwF,KAAKwB,GACdiG,EAAkBjN,KAE7BgN,EAAWhN,GAAO,CAACgH,GAEnBiG,EAAkBjN,GAAOK,GAAIL,GAAK6H,MAAMmM,IAEpC,GAAuB,MAAnBhH,EAAWhN,GAEf,IAGI,IAAI0K,EAAiBqJ,QAAWvU,EAAWwN,EAAWhN,IAAM,GAI5D,MAAMmU,EAA+B9R,IAAAA,SAAW2K,EAAWhN,GAAM,aAG1DgN,EAAWhN,UACXiN,EAAkBjN,GAGzB,MAAM,WAACiT,GAAcK,GAAiBtT,EAAK0K,GAKrC9B,EAAeuL,EAA+BzJ,EAAiBqJ,GAAWC,EAAe,CAACtJ,IAAiB,GAM5GsJ,IACDtJ,EAAiBqJ,QAAWvU,EAAW,CAACkL,IAAiB,IAG7D,MAAMsI,EAAahE,EAAAA,gBAAsBhP,EAAK4I,GAGxC+K,EAAgBb,GAAgB9S,EAAK4I,EAAc,QAASoK,EAAYC,GAG9E,OAAKD,GAAcnF,IAAcoF,EACtBU,EAGJtJ,EAAAA,UAAkBrK,EAAK0K,EAAgB9B,GAAcf,MAAK,IAAM8L,GAC3E,CAAE,MAAO5J,GAEL,OADAkF,EAAiB,mDAAkDjP,aAAe+J,KAC3E7B,QAAQoE,SACnB,KAGGW,EAAkBjN,KAxErBwT,EAAsB,CAACC,KAAMhH,EAAOE,MAAO3M,MAAKgH,YACzCkB,QAAQoE,UAwEvB,CAOA,SAAS8H,KACL,OAAO/J,EAAAA,SAAiBhI,IAAAA,KAAOmL,IAAmB3F,MAAMG,IACpD,MAAMqM,EAAWhS,IAAAA,OAAS2F,GAEpBsM,EAAS/P,EAAMxC,UAAUsS,EAAU7G,GACzCwB,EAAAA,MAAYsF,GACZjS,IAAAA,KAAOiS,GAAQ,CAAC3S,EAAK3B,IAAQ2R,GAAW3R,EAAK2B,IAAK,GAE1D,CAwBA,SAASoH,KAA4B,IAAtBwL,EAAcpS,UAAAC,OAAA,QAAA5C,IAAA2C,UAAA,GAAAA,UAAA,GAAG,GAC5B,OAAKoR,IAKD1F,GACO3F,QAAQoE,WAGnBuB,IAAa,EAENnK,KAAamE,MAAMrF,IACtB,MAAMgS,EAA6B,GAC7BC,EAA+B,CAAC,EAChCC,EAA+B,CAAC,EAOtCrS,IAAAA,KAAOG,GAAOxC,IACV,MAAM2U,EAAkBtS,IAAAA,SAAWkS,EAAgBvU,GAC7C4U,EAAevS,IAAAA,IAAMmL,EAAkBxN,GAM7C,IAAK2U,EAAiB,CAClB,MAAME,EAAW7F,EAAAA,SAAehP,GAC1B2G,EAAWtE,IAAAA,IAAMmL,EAAkBxN,EAAK,MAC9C,GAAI2G,IAAakO,EAAU,CACvB7F,EAAAA,IAAUhP,EAAK2G,GACf,MAAM2I,EAAgBtP,EAAI+L,UAAU,EAAG/L,EAAI8U,QAAQ,KAAO,GACtDxF,GACKmF,EAA6BnF,KAC9BmF,EAA6BnF,GAAiB,CAAC,GAEnDmF,EAA6BnF,GAAetP,GAAO2G,GAEnD+N,EAA6B1U,GAAO2G,CAE5C,CACJ,CAEIgO,GAAmBC,GAKvBJ,EAA2BhP,KAAKxF,EAAI,IAGxC,MAAM8T,EAAiB,GAGvBzR,IAAAA,KAAOqS,GAA8B,CAACtT,EAAOpB,KACzC8T,EAAetO,KAAK8M,GAAyBtS,EAAKoB,GAAO,IAE7DiB,IAAAA,KAAOoS,GAA8B,CAACrT,EAAOpB,KACzC8T,EAAetO,KAAK+M,GAAoCvS,EAAKoB,GAAO,IAGxE,MAAM2T,EAAuB1S,IAAAA,MAAQA,IAAAA,KAAOmL,EAAkB+G,IAI9D,OADAlS,IAAAA,KAAOmS,GAA6BxU,GAAQgP,EAAAA,KAAWhP,KAChDqK,EAAAA,YAAoBmK,GACtB3M,MAAK,IAAMwC,EAAAA,SAAiB0K,KAC5BlN,MAAK,KACFgG,IAAa,EACb2F,EAAsB,CAACC,KAAMhH,EAAOK,MAAOyH,mBACpCrM,QAAQC,IAAI2L,KACrB,MAzENN,EAAsB,CAACC,KAAMhH,EAAOK,MAAOyH,mBACpCrM,QAAQoE,UA0EvB,CAgBA,SAAS0I,GAAgB1F,EAAeT,GACpC,IAAKxM,IAAAA,SAAWwM,IAAexM,IAAAA,QAAUwM,IAAexM,IAAAA,QAAUwM,GAE9D,OADAI,EAAe,+EACR/G,QAAQoE,UAInB,IAAI2I,GAA8B,EAelC,OAdA5S,IAAAA,KAAOwM,GAAY,CAACqG,EAAOlE,KACnBzB,GAAWD,EAAe0B,KAQ9BiE,GAA8B,EAC9BhG,EAAiB,8FAA6FK,eAA2B0B,KAAU,IAInJiE,EACO/M,QAAQoE,UAGZ5I,KAAamE,MAAMsN,IAEtB,MAAOC,EAAcC,GAAWhT,IAAAA,MAAQwM,GACnCyG,MAAK,CAAClU,EAAOpB,KACNqC,IAAAA,OAASjB,KACToR,GAAOxS,IACA,KAIdwC,OACA+S,WAAWvV,GAAQmV,EAAcK,SAASxV,KAC1CoB,QAECqU,EAAwBpT,IAAAA,KAAOwM,EAAYuG,GAC3CtD,EAAgBzP,IAAAA,KAAOwM,EAAYwG,GACnCK,EAAqC9B,GAA+B6B,GACpEE,EAAgC/B,GAA+B9B,GAE/D8D,EAAW,GAIbF,EAAmCtT,OAAS,GAC5CwT,EAASpQ,KAAK6E,EAAAA,WAAmBqL,IAGjCC,EAA8BvT,OAAS,GACvCwT,EAASpQ,KAAK6E,EAAAA,SAAiBsL,IAKnC,MAAME,EAAgB3N,QAAQC,IAAI9F,IAAAA,IAAM+S,EAAc/U,KAAMwH,MAAK,KAC7DmH,EAAAA,MAAYH,GACL0D,GAAoCjD,EAAeT,MAG9D,OAAO3G,QAAQC,IAAIyN,GACd9L,OAAOC,GAAU4I,GAAqB5I,EAAOiL,GAAiBnG,KAC9DhH,MAAK,IAAMgO,GAAc,GAEtC,CAQA,SAASC,GAAOzR,GAEZhC,IAAAA,KAAOgC,GAAM0R,IAA+B,IAA9B,WAACnD,EAAU,IAAE5S,EAAG,MAAEoB,GAAM2U,EAClC,IAAK1T,IAAAA,SAAW,CAACoK,EAAOK,MAAOL,EAAOC,IAAKD,EAAOE,MAAOF,EAAOG,iBAAkBH,EAAOI,WAAY+F,GACjG,MAAM,IAAIhV,MAAO,sBAAqBgV,qBAE1C,GAAIA,IAAenG,EAAOI,WAEtB,IAAKxK,IAAAA,SAAWjB,IAAUiB,IAAAA,QAAUjB,IAAUiB,IAAAA,WAAajB,GACvD,MAAM,IAAIxD,MAAM,6FAEjB,GAAIgV,IAAenG,EAAOK,QAAUzK,IAAAA,SAAWrC,GAClD,MAAM,IAAIpC,MAAO,kBAAiBoC,kEACtC,IAGJ,MAAM4V,EAAW,GACjB,IAAII,EAAe9N,QAAQoE,UAwB3B,OAtBAjK,IAAAA,KAAOgC,GAAM4R,IAA+B,IAA9B,WAACrD,EAAU,IAAE5S,EAAG,MAAEoB,GAAM6U,EAClC,OAAQrD,GACJ,KAAKnG,EAAOC,IACRkJ,EAASpQ,MAAK,IAAMvB,GAAIjE,EAAKoB,KAC7B,MACJ,KAAKqL,EAAOE,MACRiJ,EAASpQ,MAAK,IAAMpB,GAAMpE,EAAKoB,KAC/B,MACJ,KAAKqL,EAAOG,iBACRgJ,EAASpQ,MAAK,IAAMwP,GAAgBhV,EAAKoB,KACzC,MACJ,KAAKqL,EAAOI,UACR+I,EAASpQ,MAAK,IAAMqD,GAASzH,KAC7B,MACJ,KAAKqL,EAAOK,MACRkJ,EAAejN,KAGT,IAIXiN,EAAanO,MAAK,IAAMK,QAAQC,IAAI9F,IAAAA,IAAMuT,GAAWM,GAAMA,QACtE,CA6IA,MAAMC,GAAO,CACTC,QA31BJ,SAAiB3P,GACb,MAAMqJ,EAAe5C,IAIrB,OAHAC,EAAuB2C,GAAgBrJ,EACvC0G,EAAuB2C,GAAcA,aAAeA,GAEf,IAAjCrJ,EAAQ0M,sBAKZ1F,GAAiB5I,QACZgD,MAAK,IAhFd,SAA0CpB,GACtC,GAAKgJ,GAAkBhJ,EAAQzG,OAK/BgP,EAAAA,8BAEIvI,EAAQwK,mBAAqB9B,GAAgB1I,EAAQzG,MAAM,CAE3D,GAAIqC,IAAAA,YAAcoE,EAAQ4P,UACtB,MAAM,IAAIzY,MAAO,0CAAyC6I,EAAQzG,4CAGtE4P,GAAmBnJ,EAAQzG,IAC/B,CACJ,CAgEoBsW,CAAiC7P,KAC5CoB,MAAK,IAIEwL,QAAQ5M,EAAQzG,MAA+B,iBAAhByG,EAAQzG,MAAqByG,EAAQzG,IAAIuW,SAAS,MAAQvH,EAAAA,YAAAA,IAAsBvI,EAAQzG,KAChH,CAACyG,EAAQzG,KAEb0D,OAEVmE,MAAMrF,IAIH,MAAM4P,EAAe/P,IAAAA,OAASG,GAAOxC,GAAQuP,GAAW9I,EAAQzG,IAAKA,KAMrE,GAA4B,IAAxBoS,EAAahQ,OAQb,OAPIqE,EAAQzG,MAAQmP,GAAgB1I,EAAQzG,MACxCgP,EAAAA,IAAUvI,EAAQzG,IAAK,WAK3B+R,GAAqBtL,EAAS,UAAMjH,GAAW,GAOnD,GAAI6C,IAAAA,WAAaoE,EAAQ2E,UAAzB,CACI,GAAI+D,GAAgB1I,EAAQzG,KAAM,CAC9B,GAAIyG,EAAQoK,0BAER,YADAsB,GAAiCC,EAAc3L,GAKnD,IAAK,IAAIhE,EAAI,EAAGA,EAAI2P,EAAahQ,OAAQK,IACrCpC,GAAI+R,EAAa3P,IAAIoF,MAAMlG,GAAQoQ,GAAqBtL,EAAS9E,EAAKyQ,EAAa3P,IAAI,KAE3F,MACJ,CAGApC,GAAIoG,EAAQzG,KAAK6H,MAAMlG,GAAQoQ,GAAqBtL,EAAS9E,EAAK8E,EAAQzG,KAAK,IAEnF,KAjBA,CAqBA,GAAIyG,EAAQwK,iBACR,OAAI9B,GAAgB1I,EAAQzG,UACxBmS,GAAiCC,EAAc3L,QAKnDpG,GAAIoG,EAAQzG,KAAK6H,MAAMlG,GAAQoQ,GAAqBtL,EAAS9E,EAAK8E,EAAQzG,KAAK,KAInFmH,QAAQ4C,MAAM,2EAfd,CAeyF,IAvEtF+F,CA6Ef,EAywBI0G,WA/vBJ,SAAoB1G,EAAc2G,GACzBtJ,EAAuB2C,KAMxB2G,GACA5G,GAA4B4G,EAAkC3G,UAG3D3C,EAAuB2C,GAClC,EAovBI7L,OACA4E,YACAzE,SACA4Q,mBACAc,UACA/M,SACArF,cACAgT,KAvEJ,WAQS,IARK,KACVlU,EAAO,CAAC,EAAC,iBACTmU,EAAmB,CAAC,EAAC,iBACrBC,EAAmB,GAAE,mBACrBC,EAAqB,IAAI,eACzBC,GAAiB,EAAK,4BACtBC,EAA8B1D,QAAQlJ,EAAAA,EAAOC,cAAa,cAC1D/D,GAAgB,GACnBlE,UAAAC,OAAA,QAAA5C,IAAA2C,UAAA,GAAAA,UAAA,GAAG,CAAC,EFliDDqR,GAAqBjS,IACjB,OAAQA,EAAQ8C,KAAKoP,MACjB,KAAKjI,EAAoB,CAIrB,MAAMwL,EAAmB9K,IAAc3K,EAAQ8C,KAAK6H,UAC9C+K,EAAmB/K,EAAY3K,EAAQ8C,KAAK6H,UAClD,GAAIM,MAAwByK,GAAqBD,GAAoBtL,EAAWnK,EAAQ8C,KAAKqH,UACzF,OAEJS,EAAiB5K,EAAQ8C,KAAKqH,SAE9BO,EAAYX,SAASF,GAAaA,MAClC,KACJ,CACA,KAAKK,EACDU,EAAiBT,EACjBQ,EAAYgL,KAAKC,MACjB3D,EAAsB,CAACC,KAAMjI,EAAoBE,WAAUQ,cAC3DD,EAAYX,SAASF,GAAaA,MAG5B,IAIlBe,EAAiBT,EACjBQ,EAAYgL,KAAKC,MAEjB3D,EAAsB,CAACC,KAAMjI,EAAoBE,WAAUQ,cAC3DE,IAEAzL,OAAOiK,iBAAiB,gBAAgB,KAC/B4B,KAGLgH,EAAsB,CAACC,KAAMhI,EAAwBC,YAAU,IEggDnE6H,IAA8B1L,MAAK,KAC1B0L,KAlETC,GAAoB4D,IAAa,IAAZ,KAAC/S,GAAK+S,EACvB,GAAK7D,IAGL,OAAQlP,EAAKoP,MACT,KAAKhH,EAAOK,MACR/D,GAAM1E,EAAKkQ,gBACX,MACJ,KAAK9H,EAAOC,IACRzI,GAAII,EAAKrE,IAAKqE,EAAKjD,OACnB,MACJ,KAAKqL,EAAOI,UACRhE,GAASxE,EAAKrE,IAAKqE,EAAKjD,OACxB,MACJ,KAAKqL,EAAOE,MACRvI,GAAMC,EAAKrE,IAAKqE,EAAK2C,SACrB,MACJ,KAAK+F,EACD,IAAKe,GACD,MAEJA,KAGM,GA6CK,IAGnBgJ,GAyER,WAEI,MAAMO,EAAWpb,EAAQ,KAIzBoE,GAAMgX,EAAS1a,oBAAoB0D,GAAK,YACxC4D,GAAMoT,EAAS1a,oBAAoBsH,GAAK,YACxC4E,GAAWwO,EAAS1a,oBAAoBkM,GAAU,iBAClDE,GAAQsO,EAAS1a,oBAAoBoM,GAAO,cAC5C3E,GAAQiT,EAAS1a,oBAAoByH,GAAO,cAC5C4Q,GAAkBqC,EAAS1a,oBAAoBqY,GAAiB,wBAChEtR,GAAa2T,EAAS1a,oBAAoB+G,GAAY,mBACtD0Q,GAAiCiD,EAAS1a,oBAAoByX,GAAgC,iBAC9F0B,GAASuB,EAAS1a,oBAAoBmZ,GAAQ,eAK9CK,GAAKlS,IAAMA,GACXkS,GAAKtN,SAAWA,GAChBsN,GAAKpN,MAAQA,GACboN,GAAK/R,MAAQA,GACb+R,GAAKnB,gBAAkBA,GACvBmB,GAAKL,OAASA,GAIdK,GAAKtZ,WAAawa,EAASxa,WAC3BsZ,GAAKpZ,aAAesa,EAASta,aAC7BoZ,GAAKrZ,aAAeua,EAASva,YACjC,CArGQwa,GAGAjR,GACAmL,GAAwC,GAGxCqF,EAAqB,GACrB7H,EAAAA,mBAAyB6H,GAK7B,MAAMU,EAAmBlV,IAAAA,OAASG,EAAKgV,YACvCpK,EAAuB/K,IAAAA,OACnBkV,GACA,CAACE,EAAK9V,KACF8V,EAAIxT,IAAItC,GAAK,GACN8V,IAEX,IAAIhU,KAIR+J,EAAmBmJ,EAGnBrJ,EAAoBsJ,EAGpB1O,QAAQC,IAAI,CA5xCLzE,KAAamE,MAAMrF,IACtBH,IAAAA,KAAOiL,GAAoBoK,IACvBrV,IAAAA,KAAOG,GAAOxC,IACLuP,GAAWmI,EAAiB1X,IAGjC4P,GAAmB5P,EAAI,GACzB,GACJ,IAoxCuDoU,OAAmCvM,KAAK4F,GAAiBnB,SAElHyK,GAA+B1U,IAAAA,WAAagI,EAAAA,oBAC5CA,EAAAA,mBAA0B,CAACrK,EAAKoB,KAC5B4N,EAAAA,IAAUhP,EAAKoB,GACfuQ,GAAW3R,EAAKoB,EAAM,GAGlC,EAaIuW,eX9oDJ,SAAwBvM,GACpB/J,EAAS+J,CACb,EW6oDIwM,uBAt0CJ,SAAgC5X,EAAK8P,GACjCD,GAA4B7P,EAAK8P,GAE5BvC,EAAkBvN,KACnBuN,EAAkBvN,GAAO,IAG7BuN,EAAkBvN,GAAKwF,KAAKsK,EAChC,EA+zCID,+BACAJ,qBACAhD,SACAzD,kBAvJJ,SAA2B6O,GACvBxN,EAAAA,kBAA0BwN,GAG1B7I,EAAAA,mBAAyB8I,IAC7B,EAmJIC,kBAv6CJ,SAA2B/X,GAAoB,IAAfyG,EAAOtE,UAAAC,OAAA,QAAA5C,IAAA2C,UAAA,GAAAA,UAAA,GAAG,CAAC,EACnCR,EAAMqN,EAAAA,SAAehP,GAEzB,GAAImP,GAAgBnP,GAAM,CACtB,MAAMgY,EAAehJ,EAAAA,aAIrB,GAA4B,IAAxBgJ,EAAa5V,OACb,OAEJ,MAAMgQ,EAAe/P,IAAAA,OAAS2V,GAAeC,GAAMA,EAAEpS,WAAW7F,KAehE2B,EAdeU,IAAAA,OACX+P,GACA,CAACC,EAAaL,KACV,MAAM7B,EAAcnB,EAAAA,SAAegD,GAMnC,OALI7B,IAGAkC,EAAYL,GAAc7B,GAEvBkC,CAAW,GAEtB,CAAC,EAIT,CAEA,GAAI5L,EAAQiI,SAAU,CAClB,MAAM6C,EAAQ9K,EAAQwK,iBAAmBxK,EAAQwK,iBAAiBM,WAAQ/R,EAC1E,OAAI2P,GAAgBnP,GACT4O,GAA6BjN,EAAK8E,EAAQiI,SAAU6C,GAExD/C,GAAgB7M,EAAK8E,EAAQiI,SAAU6C,EAClD,CAEA,OAAO5P,CACX,EAk4CIyR,yBACA8E,QA/IJ,SAAiB9M,GACb0C,GAAkB1C,CACtB,EA8II+M,qBAAsB5E,EACtB/G,kBAAmB+G,EACnB6E,wBFtnDJ,SAAiChN,GAC7Ba,EAAYzG,KAAK4F,EACrB,GE6pDA,M,qRE5rDA,MAAMiN,GAAqC,CAAC,eAAgB,kBAmBtDC,GAAuBA,CAAC/G,EAAOgH,IAAuBlW,IAAAA,KAAOkP,EAAOlP,IAAAA,KAAOkW,IAElE,SAAS,GAACC,GAA6C,IAA7BC,EAAkBtW,UAAAC,OAAA,QAAA5C,IAAA2C,UAAA,IAAAA,UAAA,GAEvD,MAAMuW,EAAsBrW,IAAAA,MAAQmW,GAC/BG,MAAMC,IAA2C,IAAhCA,EAAOzF,uBACxB3Q,OACApB,QACL,OAAQyX,IACJ,MAAMzR,GApBU0R,EAoBmBD,GAnBtBzR,aAAe0R,EAAUjb,MAAQ,YADtD,IAAwBib,EAqBhB,MAAMC,UAAiBC,KAAAA,UAGnB7V,YAAY9F,G,UACR4b,MAAM5b,G,EAAO,K,EAHE,I,+SAGF,uB,wFACbmD,KAAKiY,mBAAqBA,EAC1BjY,KAAK0R,iBAAmB1R,KAAK0R,iBAAiBgH,KAAK1Y,MACnDA,KAAK2Y,sBAAwB3Y,KAAK2Y,sBAAsBD,KAAK1Y,MAI7DA,KAAK4Y,oBAAsB,CAAC,EAE5B,MAAMC,EAAchX,IAAAA,OAChBmW,GACA,CAACc,EAAW7S,EAAS8S,KACjB,MAAMvZ,EAAMgM,EAAWvF,EAAQzG,IAAK3C,GACpC,IAAI+D,EAAQ+U,GAAAA,kBAAuBnW,EAAKyG,GAqBxC,OApBKrF,GAASqF,EAAQ+S,eAClBpY,EAAQqF,EAAQ+S,oBAcLha,IAAV4B,IAAwB+U,GAAAA,sBAA2BnW,IAASyG,EAAQgT,kBAErEH,EAAUC,GAAgBnY,GAGvBkY,CAAS,GAEpB,CAAC,GAILD,EAAYK,QAAUrX,IAAAA,KAAOgX,GAAeX,EAAoBtW,OAGhE5B,KAAKmZ,UAAYN,EAEjB7Y,KAAK+Q,MAAQ8H,CACjB,CAEAO,oBACI,MAAMC,EAAoBvB,GAAqB9X,KAAK+Q,MAAOiH,GAG3DnW,IAAAA,KAAOmW,GAAgB,CAAC/R,EAAS8S,KAC7B,GAAIlX,IAAAA,SAAWgW,GAAoCkB,GAC/C,OAEJ,MAAMvZ,EAAMgM,EAAWvF,EAAQzG,IAAK,IAAIQ,KAAKnD,SAAUwc,IACvDrZ,KAAKsZ,qBAAqBrT,EAAS8S,EAAcvZ,EAAI,IAEzDQ,KAAKuZ,oBACT,CAEAC,mBAAmBC,EAAW9I,GAI1B,MAAM+I,EAAkC/I,EAAUuI,UAAYlZ,KAAK+Q,MAAMmI,QACnEG,EAAoBvB,GAAqB9X,KAAK+Q,MAAOiH,GACrD2B,EAAwB7B,GAAqBnH,EAAWqH,GAE9DnW,IAAAA,KAAOmW,GAAgB,CAAC/R,EAASnJ,KAE7B,GAAI+E,IAAAA,SAAWgW,GAAoC/a,GAC/C,OAUJ,MAAM8c,EAAcF,EAAkCzT,EAAQ2T,YAAcpO,EAAWvF,EAAQzG,IAAK,IAAIia,KAAcE,IAChHE,EAASrO,EAAWvF,EAAQzG,IAAK,IAAIQ,KAAKnD,SAAUwc,IACtDO,IAAgBC,IAChBlE,GAAAA,WAAgB3V,KAAK4Y,oBAAoBgB,GAAcA,UAChD5Z,KAAK4Y,oBAAoBgB,GAChC5Z,KAAKsZ,qBAAqBrT,EAASnJ,EAAU+c,GACjD,IAEJ7Z,KAAKuZ,oBACT,CAEAO,uBAEIjY,IAAAA,KAAOmW,GAAiB/R,IACpB,MAAMzG,EAAMgM,EAAWvF,EAAQzG,IAAK,IAAIQ,KAAKnD,SAAUib,GAAqB9X,KAAK+Q,MAAOiH,KACxFrC,GAAAA,WAAgB3V,KAAK4Y,oBAAoBpZ,GAAMA,EAAI,GAE3D,CAEAkR,cAAcqJ,GACN/Z,KAAKiY,mBACLjY,KAAKga,iBAAiBhV,KAAK+U,GAE3B/Z,KAAKia,SAASF,EAEtB,CAoBArI,iBAAiBb,EAAmB1P,GAChC,MAAM+Y,EAAYla,KAAK+Q,MAAMF,GAS7B,IAAK7Q,KAAK+Q,MAAMmI,UAAYlZ,KAAKmZ,UAAW,CAExC,GAAIe,IAAc/Y,GAAO4C,EAAMxB,gBAAgB2X,EAAW/Y,GACtD,OAIJ,YADAnB,KAAK0Q,cAAc,CAAC,CAACG,GAAoB1P,GAE7C,CAMA,GAJAnB,KAAKmZ,UAAUtI,GAAqB1P,EAGNU,IAAAA,KAAOqW,GAAsB1Y,GAAQqC,IAAAA,YAAc7B,KAAKmZ,UAAU3Z,MAE5F,OAGJ,MAAM2a,EAAc,IAAIna,KAAKmZ,kBACtBnZ,KAAKmZ,UAGZnZ,KAAKia,UAAUtJ,IACX,MAAMyJ,EAAavY,IAAAA,OACfsY,GACA,CAAC3U,EAAQ5E,EAAOpB,KACZ,GAAY,YAARA,EACA,OAAOgG,EAGX,MAAMwT,EAAehB,EAAexY,GAAKwZ,aAgBzC,OAZKnX,IAAAA,YAAcmX,IAAkBnX,IAAAA,YAAc8O,EAAUnR,KAASmR,EAAUnR,KAASwZ,IAK7EnX,IAAAA,YAAc8O,EAAUnR,IAKhCgG,EAAOhG,GAAOoB,EARd4E,EAAOhG,GAAOmR,EAAUnR,GAUrBgG,CAAM,GAEjB,CAAC,GAIL,OADA4U,EAAWlB,SAAU,EACdkB,CAAU,GAEzB,CAOAb,qBAII1X,IAAAA,KAAOmW,GAAiB/R,IACpB,GAAIpE,IAAAA,YAAcoE,EAAQ4P,UACtB,OAGJ,MAAMA,EAAWrK,EAAWvF,EAAQ4P,SAAU7V,KAAKnD,OAC7C2C,EAAMgM,EAAWvF,EAAQzG,IAAKQ,KAAKnD,OAEzC,IAAK8Y,GAAAA,kBAAuBnW,GACxB,MAAM,IAAIpC,MAAO,kCAAiCoC,kHAGlDqW,EACAF,GAAAA,4BAAiCnW,EAAKyG,EAAQqJ,cAE9CqG,GAAAA,uBAA4BnW,EAAKyG,EAAQqJ,aAC7C,GAER,CAaAgK,qBAAqBrT,EAAS4K,EAAmBrR,GAI7CwY,EAAenH,GAAmB+I,YAAcpa,EAGhDQ,KAAK4Y,oBAAoBpZ,GAAOmW,GAAAA,QAAa,IACtC1P,EACHzG,MACAqR,oBACAJ,iBAAkBzQ,KAClB4G,eAER,CAEA+R,wBACS3Y,KAAKiY,qBAIVjY,KAAKiY,oBAAqB,EAE1BjY,KAAKga,iBAAiBlP,SAASiP,IAC3B/Z,KAAKia,SAASF,EAAS,IAE3B/Z,KAAKga,iBAAmB,GAC5B,CAEAK,SAEI,MAAMC,EAAczY,IAAAA,KAAO7B,KAAKnD,MAAOgF,IAAAA,QAEvC,GAAI7B,KAAK+Q,MAAMmI,QACX,OAAO,KAKX,IAAIqB,EAAc1Y,IAAAA,KAAO7B,KAAK+Q,MAAO,WAIrC,OAHAwJ,EAAc1Y,IAAAA,KAAO0Y,EAAa1Y,IAAAA,QAI9B2W,KAAAA,cAACH,EAAgBmC,GAAA,CACbC,sBAAuBza,KAAK2Y,uBAExB2B,EAEAC,EAAW,CACfG,IAAK1a,KAAKnD,MAAM8d,eAG5B,EAcJ,OAXApC,EAASqC,UAAY,CACjBD,aAAchc,KAAAA,UAAoB,CAC9BA,KAAAA,KAEAA,KAAAA,MAAgB,CAACkc,QAASlc,KAAAA,YAGlC4Z,EAASuC,aAAe,CACpBH,kBAAc3b,GAElBuZ,EAAS3R,YAAe,YAAWA,KAC5B4R,KAAAA,YAAiB,CAAC3b,EAAO6d,KAC5B,MAAMK,EAAYxC,EAClB,OACIC,KAAAA,cAACuC,EACGP,GAAA,GACI3d,EAAK,CACT8d,aAAcD,IAChB,GAER,CAEV,CCpWA,W","sources":["webpack://react-native-onyx/web/webpack/universalModuleDefinition","webpack://react-native-onyx/web/./lib/metrics/index.web.js","webpack://react-native-onyx/web/./node_modules/prop-types/factoryWithThrowingShims.js","webpack://react-native-onyx/web/./node_modules/prop-types/index.js","webpack://react-native-onyx/web/./node_modules/prop-types/lib/ReactPropTypesSecret.js","webpack://react-native-onyx/web/external umd \"fast-equals\"","webpack://react-native-onyx/web/external umd \"idb-keyval\"","webpack://react-native-onyx/web/external umd \"lodash/transform\"","webpack://react-native-onyx/web/external umd \"react\"","webpack://react-native-onyx/web/external umd \"react-dom\"","webpack://react-native-onyx/web/external umd \"underscore\"","webpack://react-native-onyx/web/webpack/bootstrap","webpack://react-native-onyx/web/webpack/runtime/compat get default export","webpack://react-native-onyx/web/webpack/runtime/define property getters","webpack://react-native-onyx/web/webpack/runtime/global","webpack://react-native-onyx/web/webpack/runtime/hasOwnProperty shorthand","webpack://react-native-onyx/web/webpack/runtime/make namespace object","webpack://react-native-onyx/web/./lib/Logger.js","webpack://react-native-onyx/web/./lib/utils.js","webpack://react-native-onyx/web/./lib/OnyxCache.js","webpack://react-native-onyx/web/./lib/Str.js","webpack://react-native-onyx/web/./lib/metrics/PerformanceUtils.js","webpack://react-native-onyx/web/./lib/storage/providers/IDBKeyVal.js","webpack://react-native-onyx/web/./lib/storage/WebStorage.js","webpack://react-native-onyx/web/./lib/storage/index.web.js","webpack://react-native-onyx/web/./lib/broadcast/index.web.js","webpack://react-native-onyx/web/./lib/ActiveClientManager/index.web.js","webpack://react-native-onyx/web/./lib/batch.js","webpack://react-native-onyx/web/./lib/Onyx.js","webpack://react-native-onyx/web/./lib/createDeferredTask.js","webpack://react-native-onyx/web/./lib/withOnyx.js","webpack://react-native-onyx/web/./lib/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"fast-equals\"), require(\"underscore\"), require(\"react-dom\"), require(\"idb-keyval\"), require(\"lodash/transform\"), require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"fast-equals\", \"underscore\", \"react-dom\", \"idb-keyval\", \"lodash/transform\", \"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"react-native-onyx/web\"] = factory(require(\"fast-equals\"), require(\"underscore\"), require(\"react-dom\"), require(\"idb-keyval\"), require(\"lodash/transform\"), require(\"react\"));\n\telse\n\t\troot[\"react-native-onyx/web\"] = factory(root[\"fast-equals\"], root[\"underscore\"], root[\"react-dom\"], root[\"idb-keyval\"], root[\"lodash/transform\"], root[\"react\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__746__, __WEBPACK_EXTERNAL_MODULE__952__, __WEBPACK_EXTERNAL_MODULE__111__, __WEBPACK_EXTERNAL_MODULE__802__, __WEBPACK_EXTERNAL_MODULE__407__, __WEBPACK_EXTERNAL_MODULE__156__) => {\nreturn ","// For web-only implementations of Onyx, this module will just be a no-op\n\nfunction decorateWithMetrics(func) {\n    return func;\n}\nfunction getMetrics() {}\nfunction printMetrics() {}\nfunction resetMetrics() {}\n\nexport {decorateWithMetrics, getMetrics, resetMetrics, printMetrics};\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');\n\nfunction emptyFunction() {}\nfunction emptyFunctionWithReset() {}\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\n\nmodule.exports = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n    var err = new Error(\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n    err.name = 'Invariant Violation';\n    throw err;\n  };\n  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  };\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    elementType: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n\n    checkPropTypes: emptyFunctionWithReset,\n    resetWarningCache: emptyFunction\n  };\n\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (process.env.NODE_ENV !== 'production') {\n  var ReactIs = require('react-is');\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = require('./factoryWithTypeCheckers')(ReactIs.isElement, throwOnDirectAccess);\n} else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = require('./factoryWithThrowingShims')();\n}\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__746__;","module.exports = __WEBPACK_EXTERNAL_MODULE__802__;","module.exports = __WEBPACK_EXTERNAL_MODULE__407__;","module.exports = __WEBPACK_EXTERNAL_MODULE__156__;","module.exports = __WEBPACK_EXTERNAL_MODULE__111__;","module.exports = __WEBPACK_EXTERNAL_MODULE__952__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Logging callback\nlet logger = () => {};\n\n/**\n * Register the logging callback\n *\n * @param {Function} callback\n */\nfunction registerLogger(callback) {\n    logger = callback;\n}\n\n/**\n * Send an alert message to the logger\n *\n * @param {String} message\n */\nfunction logAlert(message) {\n    logger({message: `[Onyx] ${message}`, level: 'alert'});\n}\n\n/**\n * Send an info message to the logger\n *\n * @param {String} message\n */\nfunction logInfo(message) {\n    logger({message: `[Onyx] ${message}`, level: 'info'});\n}\n\nexport {registerLogger, logInfo, logAlert};\n","import _ from 'underscore';\n\nfunction areObjectsEmpty(a, b) {\n    return typeof a === 'object' && typeof b === 'object' && _.isEmpty(a) && _.isEmpty(b);\n}\n\n// Mostly copied from https://medium.com/@lubaka.a/how-to-remove-lodash-performance-improvement-b306669ad0e1\n\n/**\n * @param {mixed} val\n * @returns {boolean}\n */\nfunction isMergeableObject(val) {\n    const nonNullObject = val != null ? typeof val === 'object' : false;\n    return (\n        nonNullObject &&\n        Object.prototype.toString.call(val) !== '[object RegExp]' &&\n        Object.prototype.toString.call(val) !== '[object Date]' &&\n        // eslint-disable-next-line rulesdir/prefer-underscore-method\n        !Array.isArray(val)\n    );\n}\n\n/**\n * @param {Object} target\n * @param {Object} source\n * @param {Boolean} shouldRemoveNullObjectValues\n * @returns {Object}\n */\nfunction mergeObject(target, source, shouldRemoveNullObjectValues = true) {\n    const destination = {};\n    if (isMergeableObject(target)) {\n        // lodash adds a small overhead so we don't use it here\n        // eslint-disable-next-line rulesdir/prefer-underscore-method\n        const targetKeys = Object.keys(target);\n        for (let i = 0; i < targetKeys.length; ++i) {\n            const key = targetKeys[i];\n\n            // If shouldRemoveNullObjectValues is true, we want to remove null values from the merged object\n            const isSourceOrTargetNull = target[key] === null || source[key] === null;\n            const shouldOmitSourceKey = shouldRemoveNullObjectValues && isSourceOrTargetNull;\n\n            if (!shouldOmitSourceKey) {\n                destination[key] = target[key];\n            }\n        }\n    }\n\n    // lodash adds a small overhead so we don't use it here\n    // eslint-disable-next-line rulesdir/prefer-underscore-method\n    const sourceKeys = Object.keys(source);\n    for (let i = 0; i < sourceKeys.length; ++i) {\n        const key = sourceKeys[i];\n\n        // If shouldRemoveNullObjectValues is true, we want to remove null values from the merged object\n        const shouldOmitSourceKey = shouldRemoveNullObjectValues && source[key] === null;\n\n        // If we pass undefined as the updated value for a key, we want to generally ignore it\n        const isSourceKeyUndefined = source[key] === undefined;\n\n        if (!isSourceKeyUndefined && !shouldOmitSourceKey) {\n            const isSourceKeyMergable = isMergeableObject(source[key]);\n\n            if (isSourceKeyMergable && target[key]) {\n                if (!shouldRemoveNullObjectValues || isSourceKeyMergable) {\n                    // eslint-disable-next-line no-use-before-define\n                    destination[key] = fastMerge(target[key], source[key], shouldRemoveNullObjectValues);\n                }\n            } else if (!shouldRemoveNullObjectValues || source[key] !== null) {\n                destination[key] = source[key];\n            }\n        }\n    }\n\n    return destination;\n}\n\n/**\n * Merges two objects and removes null values if \"shouldRemoveNullObjectValues\" is set to true\n *\n * We generally want to remove null values from objects written to disk and cache, because it decreases the amount of data stored in memory and on disk.\n * On native, when merging an existing value with new changes, SQLite will use JSON_PATCH, which removes top-level nullish values.\n * To be consistent with the behaviour for merge, we'll also want to remove null values for \"set\" operations.\n *\n * @param {Object|Array} target\n * @param {Object|Array} source\n * @param {Boolean} shouldRemoveNullObjectValues\n * @returns {Object|Array}\n */\nfunction fastMerge(target, source, shouldRemoveNullObjectValues = true) {\n    // We have to ignore arrays and nullish values here,\n    // otherwise \"mergeObject\" will throw an error,\n    // because it expects an object as \"source\"\n    if (_.isArray(source) || source === null || source === undefined) {\n        return source;\n    }\n    return mergeObject(target, source, shouldRemoveNullObjectValues);\n}\n\nfunction removeNestedNullValues(value) {\n    if (typeof value === 'object' && !_.isArray(value)) {\n        return fastMerge(value, value);\n    }\n\n    return value;\n}\n\nexport default {areObjectsEmpty, fastMerge, removeNestedNullValues};\n","import _ from 'underscore';\nimport {deepEqual} from 'fast-equals';\nimport utils from './utils';\n\nconst isDefined = _.negate(_.isUndefined);\n\n/**\n * In memory cache providing data by reference\n * Encapsulates Onyx cache related functionality\n */\nclass OnyxCache {\n    constructor() {\n        /**\n         * @private\n         * Cache of all the storage keys available in persistent storage\n         * @type {Set<string>}\n         */\n        this.storageKeys = new Set();\n\n        /**\n         * @private\n         * Unique list of keys maintained in access order (most recent at the end)\n         * @type {Set<string>}\n         */\n        this.recentKeys = new Set();\n\n        /**\n         * @private\n         * A map of cached values\n         * @type {Record<string, *>}\n         */\n        this.storageMap = {};\n\n        /**\n         * @private\n         * Captured pending tasks for already running storage methods\n         * Using a map yields better performance on operations such a delete\n         * https://www.zhenghao.io/posts/object-vs-map\n         * @type {Map<string, Promise>}\n         */\n        this.pendingPromises = new Map();\n\n        // bind all public methods to prevent problems with `this`\n        _.bindAll(\n            this,\n            'getAllKeys',\n            'getValue',\n            'hasCacheForKey',\n            'addKey',\n            'set',\n            'drop',\n            'merge',\n            'hasPendingTask',\n            'getTaskPromise',\n            'captureTask',\n            'removeLeastRecentlyUsedKeys',\n            'setRecentKeysLimit',\n        );\n    }\n\n    /**\n     * Get all the storage keys\n     * @returns {string[]}\n     */\n    getAllKeys() {\n        return Array.from(this.storageKeys);\n    }\n\n    /**\n     * Get a cached value from storage\n     * @param {string} key\n     * @returns {*}\n     */\n    getValue(key) {\n        this.addToAccessedKeys(key);\n        return this.storageMap[key];\n    }\n\n    /**\n     * Check whether cache has data for the given key\n     * @param {string} key\n     * @returns {boolean}\n     */\n    hasCacheForKey(key) {\n        return isDefined(this.storageMap[key]);\n    }\n\n    /**\n     * Saves a key in the storage keys list\n     * Serves to keep the result of `getAllKeys` up to date\n     * @param {string} key\n     */\n    addKey(key) {\n        this.storageKeys.add(key);\n    }\n\n    /**\n     * Set's a key value in cache\n     * Adds the key to the storage keys list as well\n     * @param {string} key\n     * @param {*} value\n     * @returns {*} value - returns the cache value\n     */\n    set(key, value) {\n        this.addKey(key);\n        this.addToAccessedKeys(key);\n        this.storageMap[key] = value;\n\n        return value;\n    }\n\n    /**\n     * Forget the cached value for the given key\n     * @param {string} key\n     */\n    drop(key) {\n        delete this.storageMap[key];\n        this.storageKeys.delete(key);\n        this.recentKeys.delete(key);\n    }\n\n    /**\n     * Deep merge data to cache, any non existing keys will be created\n     * @param {Record<string, *>} data - a map of (cache) key - values\n     */\n    merge(data) {\n        if (!_.isObject(data) || _.isArray(data)) {\n            throw new Error('data passed to cache.merge() must be an Object of onyx key/value pairs');\n        }\n\n        // lodash adds a small overhead so we don't use it here\n        // eslint-disable-next-line prefer-object-spread, rulesdir/prefer-underscore-method\n        this.storageMap = Object.assign({}, utils.fastMerge(this.storageMap, data, false));\n\n        const storageKeys = this.getAllKeys();\n        const mergedKeys = _.keys(data);\n        this.storageKeys = new Set([...storageKeys, ...mergedKeys]);\n        _.each(mergedKeys, (key) => this.addToAccessedKeys(key));\n    }\n\n    /**\n     * Check whether the given task is already running\n     * @param {string} taskName - unique name given for the task\n     * @returns {*}\n     */\n    hasPendingTask(taskName) {\n        return isDefined(this.pendingPromises.get(taskName));\n    }\n\n    /**\n     * Use this method to prevent concurrent calls for the same thing\n     * Instead of calling the same task again use the existing promise\n     * provided from this function\n     * @template T\n     * @param {string} taskName - unique name given for the task\n     * @returns {Promise<T>}\n     */\n    getTaskPromise(taskName) {\n        return this.pendingPromises.get(taskName);\n    }\n\n    /**\n     * Capture a promise for a given task so other caller can\n     * hook up to the promise if it's still pending\n     * @template T\n     * @param {string} taskName - unique name for the task\n     * @param {Promise<T>} promise\n     * @returns {Promise<T>}\n     */\n    captureTask(taskName, promise) {\n        const returnPromise = promise.finally(() => {\n            this.pendingPromises.delete(taskName);\n        });\n\n        this.pendingPromises.set(taskName, returnPromise);\n\n        return returnPromise;\n    }\n\n    /**\n     * @private\n     * Adds a key to the top of the recently accessed keys\n     * @param {string} key\n     */\n    addToAccessedKeys(key) {\n        // Removing and re-adding a key ensures it's at the end of the list\n        this.recentKeys.delete(key);\n        this.recentKeys.add(key);\n    }\n\n    /**\n     * Remove keys that don't fall into the range of recently used keys\n     */\n    removeLeastRecentlyUsedKeys() {\n        let numKeysToRemove = this.recentKeys.size - this.maxRecentKeysSize;\n        if (numKeysToRemove <= 0) {\n            return;\n        }\n        const iterator = this.recentKeys.values();\n        const temp = [];\n        while (numKeysToRemove > 0) {\n            const value = iterator.next().value;\n            temp.push(value);\n            numKeysToRemove--;\n        }\n\n        for (let i = 0; i < temp.length; ++i) {\n            delete this.storageMap[temp[i]];\n            this.recentKeys.delete(temp[i]);\n        }\n    }\n\n    /**\n     * Set the recent keys list size\n     * @param {number} limit\n     */\n    setRecentKeysLimit(limit) {\n        this.maxRecentKeysSize = limit;\n    }\n\n    /**\n     * @param {String} key\n     * @param {*} value\n     * @returns {Boolean}\n     */\n    hasValueChanged(key, value) {\n        return !deepEqual(this.storageMap[key], value);\n    }\n}\n\nconst instance = new OnyxCache();\n\nexport default instance;\n","import _ from 'underscore';\n\n/**\n * Returns true if the haystack begins with the needle\n *\n * @param {String} haystack  The full string to be searched\n * @param {String} needle    The case-sensitive string to search for\n * @return {Boolean} Returns true if the haystack starts with the needle.\n */\nfunction startsWith(haystack, needle) {\n    return _.isString(haystack) && _.isString(needle) && haystack.startsWith(needle);\n}\n\n/**\n * Checks if parameter is a string or function.\n * If it is a string, then we will just return it.\n * If it is a function, then we will call it with\n * any additional arguments and return the result.\n *\n * @param {String|Function} parameter\n * @returns {*}\n */\nfunction result(parameter, ...args) {\n    return _.isFunction(parameter) ? parameter(...args) : parameter;\n}\n\n/**\n * A simple GUID generator taken from https://stackoverflow.com/a/32760401/9114791\n *\n * @param {String} [prefix] an optional prefix to put in front of the guid\n * @returns {String}\n */\nfunction guid(prefix = '') {\n    function s4() {\n        return Math.floor((1 + Math.random()) * 0x10000)\n            .toString(16)\n            .substring(1);\n    }\n    return `${prefix}${s4()}${s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`;\n}\n\nexport {guid, startsWith, result};\n","import lodashTransform from 'lodash/transform';\nimport _ from 'underscore';\n\nlet debugSetState = false;\n\n/**\n * @param {Boolean} debug\n */\nfunction setShouldDebugSetState(debug) {\n    debugSetState = debug;\n}\n\n/**\n * Deep diff between two objects. Useful for figuring out what changed about an object from one render to the next so\n * that state and props updates can be optimized.\n *\n * @param  {Object} object\n * @param  {Object} base\n * @return {Object}\n */\nfunction diffObject(object, base) {\n    function changes(obj, comparisonObject) {\n        return lodashTransform(obj, (result, value, key) => {\n            if (_.isEqual(value, comparisonObject[key])) {\n                return;\n            }\n\n            // eslint-disable-next-line no-param-reassign\n            result[key] = _.isObject(value) && _.isObject(comparisonObject[key]) ? changes(value, comparisonObject[key]) : value;\n        });\n    }\n    return changes(object, base);\n}\n\n/**\n * Provide insights into why a setState() call occurred by diffing the before and after values.\n *\n * @param {Object} mapping\n * @param {*} previousValue\n * @param {*} newValue\n * @param {String} caller\n * @param {String} [keyThatChanged]\n */\nfunction logSetStateCall(mapping, previousValue, newValue, caller, keyThatChanged) {\n    if (!debugSetState) {\n        return;\n    }\n\n    const logParams = {};\n    if (keyThatChanged) {\n        logParams.keyThatChanged = keyThatChanged;\n    }\n    if (_.isObject(newValue) && _.isObject(previousValue)) {\n        logParams.difference = diffObject(previousValue, newValue);\n    } else {\n        logParams.previousValue = previousValue;\n        logParams.newValue = newValue;\n    }\n\n    console.debug(`[Onyx-Debug] ${mapping.displayName} setState() called. Subscribed to key '${mapping.key}' (${caller})`, logParams);\n}\n\nexport {logSetStateCall, setShouldDebugSetState};\n","import {set, keys, getMany, setMany, get, clear, del, delMany, createStore, promisifyRequest} from 'idb-keyval';\nimport _ from 'underscore';\nimport utils from '../../utils';\n\n// We don't want to initialize the store while the JS bundle loads as idb-keyval will try to use global.indexedDB\n// which might not be available in certain environments that load the bundle (e.g. electron main process).\nlet customStoreInstance;\nconst getCustomStore = () => {\n    if (!customStoreInstance) {\n        customStoreInstance = createStore('OnyxDB', 'keyvaluepairs');\n    }\n    return customStoreInstance;\n};\n\nconst provider = {\n    /**\n     * Sets the value for a given key. The only requirement is that the value should be serializable to JSON string\n     * @param {String} key\n     * @param {*} value\n     * @return {Promise<void>}\n     */\n    setItem: (key, value) => set(key, value, getCustomStore()),\n\n    /**\n     * Get multiple key-value pairs for the give array of keys in a batch.\n     * This is optimized to use only one database transaction.\n     * @param {String[]} keysParam\n     * @return {Promise<Array<[key, value]>>}\n     */\n    multiGet: (keysParam) => getMany(keysParam, getCustomStore()).then((values) => _.map(values, (value, index) => [keysParam[index], value])),\n\n    /**\n     * Multiple merging of existing and new values in a batch\n     * @param {Array<[key, value]>} pairs\n     * This function also removes all nested null values from an object.\n     * @return {Promise<void>}\n     */\n    multiMerge: (pairs) =>\n        getCustomStore()('readwrite', (store) => {\n            // Note: we are using the manual store transaction here, to fit the read and update\n            // of the items in one transaction to achieve best performance.\n\n            const getValues = Promise.all(_.map(pairs, ([key]) => promisifyRequest(store.get(key))));\n\n            return getValues.then((values) => {\n                const upsertMany = _.map(pairs, ([key, value], index) => {\n                    const prev = values[index];\n                    const newValue = utils.fastMerge(prev, value);\n                    return promisifyRequest(store.put(newValue, key));\n                });\n                return Promise.all(upsertMany);\n            });\n        }),\n\n    /**\n     * Merging an existing value with a new one\n     * @param {String} key\n     * @param {any} _changes - not used, as we rely on the pre-merged data from the `modifiedData`\n     * @param {any} modifiedData - the pre-merged data from `Onyx.applyMerge`\n     * @return {Promise<void>}\n     */\n    mergeItem(key, _changes, modifiedData) {\n        // Since Onyx also merged the existing value with the changes, we can just set the value directly\n        return provider.setItem(key, modifiedData);\n    },\n\n    /**\n     * Stores multiple key-value pairs in a batch\n     * @param {Array<[key, value]>} pairs\n     * @return {Promise<void>}\n     */\n    multiSet: (pairs) => setMany(pairs, getCustomStore()),\n\n    /**\n     * Clear everything from storage and also stops the SyncQueue from adding anything more to storage\n     * @returns {Promise<void>}\n     */\n    clear: () => clear(getCustomStore()),\n\n    // This is a noop for now in order to keep clients from crashing see https://github.com/Expensify/Expensify/issues/312438\n    setMemoryOnlyKeys: () => {},\n\n    /**\n     * Returns all keys available in storage\n     * @returns {Promise<String[]>}\n     */\n    getAllKeys: () => keys(getCustomStore()),\n\n    /**\n     * Get the value of a given key or return `null` if it's not available in storage\n     * @param {String} key\n     * @return {Promise<*>}\n     */\n    getItem: (key) =>\n        get(key, getCustomStore())\n            // idb-keyval returns undefined for missing items, but this needs to return null so that idb-keyval does the same thing as SQLiteStorage.\n            .then((val) => (val === undefined ? null : val)),\n\n    /**\n     * Remove given key and it's value from storage\n     * @param {String} key\n     * @returns {Promise<void>}\n     */\n    removeItem: (key) => del(key, getCustomStore()),\n\n    /**\n     * Remove given keys and their values from storage\n     *\n     * @param {Array} keysParam\n     * @returns {Promise}\n     */\n    removeItems: (keysParam) => delMany(keysParam, getCustomStore()),\n\n    /**\n     * Gets the total bytes of the database file\n     * @returns {Promise<number>}\n     */\n    getDatabaseSize() {\n        if (!window.navigator || !window.navigator.storage) {\n            throw new Error('StorageManager browser API unavailable');\n        }\n\n        return window.navigator.storage\n            .estimate()\n            .then((value) => ({\n                bytesUsed: value.usage,\n                bytesRemaining: value.quota - value.usage,\n            }))\n            .catch((error) => {\n                throw new Error(`Unable to estimate web storage quota. Original error: ${error}`);\n            });\n    },\n};\n\nexport default provider;\n","/**\n * This file is here to wrap IDBKeyVal with a layer that provides data-changed events like the ones that exist\n * when using LocalStorage APIs in the browser. These events are great because multiple tabs can listen for when\n * data changes and then stay up-to-date with everything happening in Onyx.\n */\nimport _ from 'underscore';\nimport Storage from './providers/IDBKeyVal';\n\nconst SYNC_ONYX = 'SYNC_ONYX';\n\n/**\n * Raise an event thorough `localStorage` to let other tabs know a value changed\n * @param {String} onyxKey\n */\nfunction raiseStorageSyncEvent(onyxKey) {\n    global.localStorage.setItem(SYNC_ONYX, onyxKey);\n    global.localStorage.removeItem(SYNC_ONYX, onyxKey);\n}\n\nfunction raiseStorageSyncManyKeysEvent(onyxKeys) {\n    _.each(onyxKeys, (onyxKey) => {\n        raiseStorageSyncEvent(onyxKey);\n    });\n}\n\nconst webStorage = {\n    ...Storage,\n\n    /**\n     * @param {Function} onStorageKeyChanged Storage synchronization mechanism keeping all opened tabs in sync\n     */\n    keepInstancesSync(onStorageKeyChanged) {\n        // Override set, remove and clear to raise storage events that we intercept in other tabs\n        this.setItem = (key, value) => Storage.setItem(key, value).then(() => raiseStorageSyncEvent(key));\n\n        this.removeItem = (key) => Storage.removeItem(key).then(() => raiseStorageSyncEvent(key));\n\n        this.removeItems = (keys) => Storage.removeItems(keys).then(() => raiseStorageSyncManyKeysEvent(keys));\n\n        this.mergeItem = (key, batchedChanges, modifiedData) => Storage.mergeItem(key, batchedChanges, modifiedData).then(() => raiseStorageSyncEvent(key));\n\n        // If we just call Storage.clear other tabs will have no idea which keys were available previously\n        // so that they can call keysChanged for them. That's why we iterate over every key and raise a storage sync\n        // event for each one\n        this.clear = () => {\n            let allKeys;\n\n            // The keys must be retrieved before storage is cleared or else the list of keys would be empty\n            return Storage.getAllKeys()\n                .then((keys) => {\n                    allKeys = keys;\n                })\n                .then(() => Storage.clear())\n                .then(() => {\n                    // Now that storage is cleared, the storage sync event can happen which is a more atomic action\n                    // for other browser tabs\n                    _.each(allKeys, raiseStorageSyncEvent);\n                });\n        };\n\n        // This listener will only be triggered by events coming from other tabs\n        global.addEventListener('storage', (event) => {\n            // Ignore events that don't originate from the SYNC_ONYX logic\n            if (event.key !== SYNC_ONYX || !event.newValue) {\n                return;\n            }\n\n            const onyxKey = event.newValue;\n            Storage.getItem(onyxKey).then((value) => onStorageKeyChanged(onyxKey, value));\n        });\n    },\n};\n\nexport default webStorage;\n","import WebStorage from './WebStorage';\n\nexport default WebStorage;\n","const BROADCAST_ONYX = 'BROADCAST_ONYX';\n\nconst subscriptions = [];\nconst channel = new BroadcastChannel(BROADCAST_ONYX);\n\n/**\n * Sends a message to the broadcast channel.\n * @param {String} message\n */\nfunction sendMessage(message) {\n    channel.postMessage(message);\n}\n\n/**\n * Subscribes to the broadcast channel. Every time a new message\n * is received, the callback is called.\n * @param {Function} callback\n */\nfunction subscribe(callback) {\n    subscriptions.push(callback);\n    channel.onmessage = (message) => {\n        subscriptions.forEach((c) => c(message));\n    };\n}\n\n/**\n * Disconnects from the broadcast channel.\n */\nfunction disconnect() {\n    channel.close();\n}\n\nexport {sendMessage, subscribe, disconnect};\n","/**\n * When you have many tabs in one browser, the data of Onyx is shared between all of them. Since we persist write requests in Onyx, we need to ensure that\n * only one tab is processing those saved requests or we would be duplicating data (or creating errors).\n * This file ensures exactly that by tracking all the clientIDs connected, storing the most recent one last and it considers that last clientID the \"leader\".\n */\n\nimport * as Str from '../Str';\nimport * as Broadcast from '../broadcast';\n\nconst NEW_LEADER_MESSAGE = 'NEW_LEADER';\nconst REMOVED_LEADER_MESSAGE = 'REMOVE_LEADER';\n\nconst clientID = Str.guid();\nconst subscribers = [];\nlet timestamp = null;\n\nlet activeClientID = null;\nlet setIsReady = () => {};\nconst isReadyPromise = new Promise((resolve) => {\n    setIsReady = resolve;\n});\n\n/**\n * Determines when the client is ready. We need to wait both till we saved our ID in onyx AND the init method was called\n * @returns {Promise}\n */\nfunction isReady() {\n    return isReadyPromise;\n}\n\n/**\n * Returns a boolean indicating if the current client is the leader.\n *\n * @returns {Boolean}\n */\nfunction isClientTheLeader() {\n    return activeClientID === clientID;\n}\n\n/**\n * Subscribes to when the client changes.\n * @param {Function} callback\n */\nfunction subscribeToClientChange(callback) {\n    subscribers.push(callback);\n}\n\n/**\n * Subscribe to the broadcast channel to listen for messages from other tabs, so that\n * all tabs agree on who the leader is, which should always be the last tab to open.\n */\nfunction init() {\n    Broadcast.subscribe((message) => {\n        switch (message.data.type) {\n            case NEW_LEADER_MESSAGE: {\n                // Only update the active leader if the message received was from another\n                // tab that initialized after the current one; if the timestamps are the\n                // same, it uses the client ID to tie-break\n                const isTimestampEqual = timestamp === message.data.timestamp;\n                const isTimestampNewer = timestamp > message.data.timestamp;\n                if (isClientTheLeader() && (isTimestampNewer || (isTimestampEqual && clientID > message.data.clientID))) {\n                    return;\n                }\n                activeClientID = message.data.clientID;\n\n                subscribers.forEach((callback) => callback());\n                break;\n            }\n            case REMOVED_LEADER_MESSAGE:\n                activeClientID = clientID;\n                timestamp = Date.now();\n                Broadcast.sendMessage({type: NEW_LEADER_MESSAGE, clientID, timestamp});\n                subscribers.forEach((callback) => callback());\n                break;\n            default:\n                break;\n        }\n    });\n\n    activeClientID = clientID;\n    timestamp = Date.now();\n\n    Broadcast.sendMessage({type: NEW_LEADER_MESSAGE, clientID, timestamp});\n    setIsReady();\n\n    window.addEventListener('beforeunload', () => {\n        if (!isClientTheLeader()) {\n            return;\n        }\n        Broadcast.sendMessage({type: REMOVED_LEADER_MESSAGE, clientID});\n    });\n}\n\nexport {isClientTheLeader, init, isReady, subscribeToClientChange};\n","import {unstable_batchedUpdates} from 'react-dom';\n\nexport default unstable_batchedUpdates;\n","/* eslint-disable no-continue */\nimport {deepEqual} from 'fast-equals';\nimport _ from 'underscore';\nimport * as Logger from './Logger';\nimport cache from './OnyxCache';\nimport * as Str from './Str';\nimport createDeferredTask from './createDeferredTask';\nimport * as PerformanceUtils from './metrics/PerformanceUtils';\nimport Storage from './storage';\nimport * as Broadcast from './broadcast';\nimport * as ActiveClientManager from './ActiveClientManager';\nimport utils from './utils';\nimport unstable_batchedUpdates from './batch';\n\n// Method constants\nconst METHOD = {\n    SET: 'set',\n    MERGE: 'merge',\n    MERGE_COLLECTION: 'mergecollection',\n    MULTI_SET: 'multiset',\n    CLEAR: 'clear',\n};\n\nconst ON_CLEAR = 'on_clear';\n\n// Key/value store of Onyx key and arrays of values to merge\nconst mergeQueue = {};\nconst mergeQueuePromise = {};\n\n// Keeps track of the last connectionID that was used so we can keep incrementing it\nlet lastConnectionID = 0;\n\n// Holds a mapping of all the react components that want their state subscribed to a store key\nconst callbackToStateMapping = {};\n\n// Keeps a copy of the values of the onyx collection keys as a map for faster lookups\nlet onyxCollectionKeyMap = new Map();\n\n// Holds a list of keys that have been directly subscribed to or recently modified from least to most recent\nlet recentlyAccessedKeys = [];\n\n// Holds a list of keys that are safe to remove when we reach max storage. If a key does not match with\n// whatever appears in this list it will NEVER be a candidate for eviction.\nlet evictionAllowList = [];\n\n// Holds a map of keys and connectionID arrays whose keys will never be automatically evicted as\n// long as we have at least one subscriber that returns false for the canEvict property.\nconst evictionBlocklist = {};\n\n// Optional user-provided key value states set when Onyx initializes or clears\nlet defaultKeyStates = {};\n\n// Connections can be made before `Onyx.init`. They would wait for this task before resolving\nconst deferredInitTask = createDeferredTask();\n\n// The promise of the clear function, saved so that no writes happen while it's executing\nlet isClearing = false;\n\n// Callback to be executed after the clear execution ends\nlet onClearCallback = null;\n\nlet batchUpdatesPromise = null;\nlet batchUpdatesQueue = [];\n\n/**\n * We are batching together onyx updates. This helps with use cases where we schedule onyx updates after each other.\n * This happens for example in the Onyx.update function, where we process API responses that might contain a lot of\n * update operations. Instead of calling the subscribers for each update operation, we batch them together which will\n * cause react to schedule the updates at once instead of after each other. This is mainly a performance optimization.\n * @returns {Promise}\n */\nfunction maybeFlushBatchUpdates() {\n    if (batchUpdatesPromise) {\n        return batchUpdatesPromise;\n    }\n\n    batchUpdatesPromise = new Promise((resolve) => {\n        /* We use (setTimeout, 0) here which should be called once native module calls are flushed (usually at the end of the frame)\n         * We may investigate if (setTimeout, 1) (which in React Native is equal to requestAnimationFrame) works even better\n         * then the batch will be flushed on next frame.\n         */\n        setTimeout(() => {\n            const updatesCopy = batchUpdatesQueue;\n            batchUpdatesQueue = [];\n            batchUpdatesPromise = null;\n            unstable_batchedUpdates(() => {\n                updatesCopy.forEach((applyUpdates) => {\n                    applyUpdates();\n                });\n            });\n\n            resolve();\n        }, 0);\n    });\n    return batchUpdatesPromise;\n}\n\nfunction batchUpdates(updates) {\n    batchUpdatesQueue.push(updates);\n    return maybeFlushBatchUpdates();\n}\n\n/**\n * Uses a selector function to return a simplified version of sourceData\n * @param {Mixed} sourceData\n * @param {Function} selector Function that takes sourceData and returns a simplified version of it\n * @param {Object} [withOnyxInstanceState]\n * @returns {Mixed}\n */\nconst getSubsetOfData = (sourceData, selector, withOnyxInstanceState) => selector(sourceData, withOnyxInstanceState);\n\n/**\n * Takes a collection of items (eg. {testKey_1:{a:'a'}, testKey_2:{b:'b'}})\n * and runs it through a reducer function to return a subset of the data according to a selector.\n * The resulting collection will only contain items that are returned by the selector.\n * @param {Object} collection\n * @param {String|Function} selector (see method docs for getSubsetOfData() for full details)\n * @param {Object} [withOnyxInstanceState]\n * @returns {Object}\n */\nconst reduceCollectionWithSelector = (collection, selector, withOnyxInstanceState) =>\n    _.reduce(\n        collection,\n        (finalCollection, item, key) => {\n            // eslint-disable-next-line no-param-reassign\n            finalCollection[key] = getSubsetOfData(item, selector, withOnyxInstanceState);\n\n            return finalCollection;\n        },\n        {},\n    );\n\n/**\n * Get some data from the store\n *\n * @private\n * @param {string} key\n * @returns {Promise<*>}\n */\nfunction get(key) {\n    // When we already have the value in cache - resolve right away\n    if (cache.hasCacheForKey(key)) {\n        return Promise.resolve(cache.getValue(key));\n    }\n\n    const taskName = `get:${key}`;\n\n    // When a value retrieving task for this key is still running hook to it\n    if (cache.hasPendingTask(taskName)) {\n        return cache.getTaskPromise(taskName);\n    }\n\n    // Otherwise retrieve the value from storage and capture a promise to aid concurrent usages\n    const promise = Storage.getItem(key)\n        .then((val) => {\n            cache.set(key, val);\n            return val;\n        })\n        .catch((err) => Logger.logInfo(`Unable to get item from persistent storage. Key: ${key} Error: ${err}`));\n\n    return cache.captureTask(taskName, promise);\n}\n\n/**\n * Returns current key names stored in persisted storage\n * @private\n * @returns {Promise<string[]>}\n */\nfunction getAllKeys() {\n    // When we've already read stored keys, resolve right away\n    const storedKeys = cache.getAllKeys();\n    if (storedKeys.length > 0) {\n        return Promise.resolve(storedKeys);\n    }\n\n    const taskName = 'getAllKeys';\n\n    // When a value retrieving task for all keys is still running hook to it\n    if (cache.hasPendingTask(taskName)) {\n        return cache.getTaskPromise(taskName);\n    }\n\n    // Otherwise retrieve the keys from storage and capture a promise to aid concurrent usages\n    const promise = Storage.getAllKeys().then((keys) => {\n        _.each(keys, (key) => cache.addKey(key));\n        return keys;\n    });\n\n    return cache.captureTask(taskName, promise);\n}\n\n/**\n * Checks to see if the a subscriber's supplied key\n * is associated with a collection of keys.\n *\n * @private\n * @param {String} key\n * @returns {Boolean}\n */\nfunction isCollectionKey(key) {\n    return onyxCollectionKeyMap.has(key);\n}\n\n/**\n * @param {String} collectionKey\n * @param {String} key\n * @returns {Boolean}\n */\nfunction isCollectionMemberKey(collectionKey, key) {\n    return Str.startsWith(key, collectionKey) && key.length > collectionKey.length;\n}\n\n/**\n * Checks to see if a provided key is the exact configured key of our connected subscriber\n * or if the provided key is a collection member key (in case our configured key is a \"collection key\")\n *\n * @private\n * @param {String} configKey\n * @param {String} key\n * @return {Boolean}\n */\nfunction isKeyMatch(configKey, key) {\n    return isCollectionKey(configKey) ? Str.startsWith(key, configKey) : configKey === key;\n}\n\n/**\n * Checks to see if this key has been flagged as\n * safe for removal.\n *\n * @private\n * @param {String} testKey\n * @returns {Boolean}\n */\nfunction isSafeEvictionKey(testKey) {\n    return _.some(evictionAllowList, (key) => isKeyMatch(key, testKey));\n}\n\n/**\n * Tries to get a value from the cache. If the value is not present in cache it will return the default value or undefined.\n * If the requested key is a collection, it will return an object with all the collection members.\n *\n * @param {String} key\n * @param {Object} mapping\n * @returns {Mixed}\n */\nfunction tryGetCachedValue(key, mapping = {}) {\n    let val = cache.getValue(key);\n\n    if (isCollectionKey(key)) {\n        const allCacheKeys = cache.getAllKeys();\n\n        // It is possible we haven't loaded all keys yet so we do not know if the\n        // collection actually exists.\n        if (allCacheKeys.length === 0) {\n            return;\n        }\n        const matchingKeys = _.filter(allCacheKeys, (k) => k.startsWith(key));\n        const values = _.reduce(\n            matchingKeys,\n            (finalObject, matchedKey) => {\n                const cachedValue = cache.getValue(matchedKey);\n                if (cachedValue) {\n                    // This is permissible because we're in the process of constructing the final object in a reduce function.\n                    // eslint-disable-next-line no-param-reassign\n                    finalObject[matchedKey] = cachedValue;\n                }\n                return finalObject;\n            },\n            {},\n        );\n\n        val = values;\n    }\n\n    if (mapping.selector) {\n        const state = mapping.withOnyxInstance ? mapping.withOnyxInstance.state : undefined;\n        if (isCollectionKey(key)) {\n            return reduceCollectionWithSelector(val, mapping.selector, state);\n        }\n        return getSubsetOfData(val, mapping.selector, state);\n    }\n\n    return val;\n}\n\n/**\n * Remove a key from the recently accessed key list.\n *\n * @private\n * @param {String} key\n */\nfunction removeLastAccessedKey(key) {\n    recentlyAccessedKeys = _.without(recentlyAccessedKeys, key);\n}\n\n/**\n * Add a key to the list of recently accessed keys. The least\n * recently accessed key should be at the head and the most\n * recently accessed key at the tail.\n *\n * @private\n * @param {String} key\n */\nfunction addLastAccessedKey(key) {\n    // Only specific keys belong in this list since we cannot remove an entire collection.\n    if (isCollectionKey(key) || !isSafeEvictionKey(key)) {\n        return;\n    }\n\n    removeLastAccessedKey(key);\n    recentlyAccessedKeys.push(key);\n}\n\n/**\n * Removes a key previously added to this list\n * which will enable it to be deleted again.\n *\n * @private\n * @param {String} key\n * @param {Number} connectionID\n */\nfunction removeFromEvictionBlockList(key, connectionID) {\n    evictionBlocklist[key] = _.without(evictionBlocklist[key] || [], connectionID);\n\n    // Remove the key if there are no more subscribers\n    if (evictionBlocklist[key].length === 0) {\n        delete evictionBlocklist[key];\n    }\n}\n\n/**\n * Keys added to this list can never be deleted.\n *\n * @private\n * @param {String} key\n * @param {Number} connectionID\n */\nfunction addToEvictionBlockList(key, connectionID) {\n    removeFromEvictionBlockList(key, connectionID);\n\n    if (!evictionBlocklist[key]) {\n        evictionBlocklist[key] = [];\n    }\n\n    evictionBlocklist[key].push(connectionID);\n}\n\n/**\n * Take all the keys that are safe to evict and add them to\n * the recently accessed list when initializing the app. This\n * enables keys that have not recently been accessed to be\n * removed.\n *\n * @private\n * @returns {Promise}\n */\nfunction addAllSafeEvictionKeysToRecentlyAccessedList() {\n    return getAllKeys().then((keys) => {\n        _.each(evictionAllowList, (safeEvictionKey) => {\n            _.each(keys, (key) => {\n                if (!isKeyMatch(safeEvictionKey, key)) {\n                    return;\n                }\n                addLastAccessedKey(key);\n            });\n        });\n    });\n}\n\n/**\n * @private\n * @param {String} collectionKey\n * @returns {Object}\n */\nfunction getCachedCollection(collectionKey) {\n    const collectionMemberKeys = _.filter(cache.getAllKeys(), (storedKey) => isCollectionMemberKey(collectionKey, storedKey));\n\n    return _.reduce(\n        collectionMemberKeys,\n        (prev, curr) => {\n            const cachedValue = cache.getValue(curr);\n            if (!cachedValue) {\n                return prev;\n            }\n\n            // eslint-disable-next-line no-param-reassign\n            prev[curr] = cachedValue;\n            return prev;\n        },\n        {},\n    );\n}\n\n/**\n * When a collection of keys change, search for any callbacks matching the collection key and trigger those callbacks\n *\n * @private\n * @param {String} collectionKey\n * @param {Object} partialCollection - a partial collection of grouped member keys\n * @param {boolean} [notifyRegularSubscibers=true]\n * @param {boolean} [notifyWithOnyxSubscibers=true]\n */\nfunction keysChanged(collectionKey, partialCollection, notifyRegularSubscibers = true, notifyWithOnyxSubscibers = true) {\n    // We are iterating over all subscribers similar to keyChanged(). However, we are looking for subscribers who are subscribing to either a collection key or\n    // individual collection key member for the collection that is being updated. It is important to note that the collection parameter cane be a PARTIAL collection\n    // and does not represent all of the combined keys and values for a collection key. It is just the \"new\" data that was merged in via mergeCollection().\n    const stateMappingKeys = _.keys(callbackToStateMapping);\n    for (let i = 0; i < stateMappingKeys.length; i++) {\n        const subscriber = callbackToStateMapping[stateMappingKeys[i]];\n        if (!subscriber) {\n            continue;\n        }\n\n        // Skip iteration if we do not have a collection key or a collection member key on this subscriber\n        if (!Str.startsWith(subscriber.key, collectionKey)) {\n            continue;\n        }\n\n        /**\n         * e.g. Onyx.connect({key: ONYXKEYS.COLLECTION.REPORT, callback: ...});\n         */\n        const isSubscribedToCollectionKey = subscriber.key === collectionKey;\n\n        /**\n         * e.g. Onyx.connect({key: `${ONYXKEYS.COLLECTION.REPORT}{reportID}`, callback: ...});\n         */\n        const isSubscribedToCollectionMemberKey = isCollectionMemberKey(collectionKey, subscriber.key);\n\n        // We prepare the \"cached collection\" which is the entire collection + the new partial data that\n        // was merged in via mergeCollection().\n        const cachedCollection = getCachedCollection(collectionKey);\n\n        // Regular Onyx.connect() subscriber found.\n        if (_.isFunction(subscriber.callback)) {\n            if (!notifyRegularSubscibers) {\n                continue;\n            }\n\n            // If they are subscribed to the collection key and using waitForCollectionCallback then we'll\n            // send the whole cached collection.\n            if (isSubscribedToCollectionKey) {\n                if (subscriber.waitForCollectionCallback) {\n                    subscriber.callback(cachedCollection);\n                    continue;\n                }\n\n                // If they are not using waitForCollectionCallback then we notify the subscriber with\n                // the new merged data but only for any keys in the partial collection.\n                const dataKeys = _.keys(partialCollection);\n                for (let j = 0; j < dataKeys.length; j++) {\n                    const dataKey = dataKeys[j];\n                    subscriber.callback(cachedCollection[dataKey], dataKey);\n                }\n                continue;\n            }\n\n            // And if the subscriber is specifically only tracking a particular collection member key then we will\n            // notify them with the cached data for that key only.\n            if (isSubscribedToCollectionMemberKey) {\n                subscriber.callback(cachedCollection[subscriber.key], subscriber.key);\n                continue;\n            }\n\n            continue;\n        }\n\n        // React component subscriber found.\n        if (subscriber.withOnyxInstance) {\n            if (!notifyWithOnyxSubscibers) {\n                continue;\n            }\n\n            // We are subscribed to a collection key so we must update the data in state with the new\n            // collection member key values from the partial update.\n            if (isSubscribedToCollectionKey) {\n                // If the subscriber has a selector, then the component's state must only be updated with the data\n                // returned by the selector.\n                if (subscriber.selector) {\n                    subscriber.withOnyxInstance.setStateProxy((prevState) => {\n                        const previousData = prevState[subscriber.statePropertyName];\n                        const newData = reduceCollectionWithSelector(cachedCollection, subscriber.selector, subscriber.withOnyxInstance.state);\n\n                        if (!deepEqual(previousData, newData)) {\n                            return {\n                                [subscriber.statePropertyName]: newData,\n                            };\n                        }\n                        return null;\n                    });\n                    continue;\n                }\n\n                subscriber.withOnyxInstance.setStateProxy((prevState) => {\n                    const finalCollection = _.clone(prevState[subscriber.statePropertyName] || {});\n                    const dataKeys = _.keys(partialCollection);\n                    for (let j = 0; j < dataKeys.length; j++) {\n                        const dataKey = dataKeys[j];\n                        finalCollection[dataKey] = cachedCollection[dataKey];\n                    }\n\n                    PerformanceUtils.logSetStateCall(subscriber, prevState[subscriber.statePropertyName], finalCollection, 'keysChanged', collectionKey);\n                    return {\n                        [subscriber.statePropertyName]: finalCollection,\n                    };\n                });\n                continue;\n            }\n\n            // If a React component is only interested in a single key then we can set the cached value directly to the state name.\n            if (isSubscribedToCollectionMemberKey) {\n                // However, we only want to update this subscriber if the partial data contains a change.\n                // Otherwise, we would update them with a value they already have and trigger an unnecessary re-render.\n                const dataFromCollection = partialCollection[subscriber.key];\n                if (_.isUndefined(dataFromCollection)) {\n                    continue;\n                }\n\n                // If the subscriber has a selector, then the component's state must only be updated with the data\n                // returned by the selector and the state should only change when the subset of data changes from what\n                // it was previously.\n                if (subscriber.selector) {\n                    subscriber.withOnyxInstance.setStateProxy((prevState) => {\n                        const prevData = prevState[subscriber.statePropertyName];\n                        const newData = getSubsetOfData(cachedCollection[subscriber.key], subscriber.selector, subscriber.withOnyxInstance.state);\n                        if (!deepEqual(prevData, newData)) {\n                            PerformanceUtils.logSetStateCall(subscriber, prevData, newData, 'keysChanged', collectionKey);\n                            return {\n                                [subscriber.statePropertyName]: newData,\n                            };\n                        }\n\n                        return null;\n                    });\n                    continue;\n                }\n\n                subscriber.withOnyxInstance.setStateProxy((prevState) => {\n                    const data = cachedCollection[subscriber.key];\n                    const previousData = prevState[subscriber.statePropertyName];\n\n                    // Avoids triggering unnecessary re-renders when feeding empty objects\n                    if (utils.areObjectsEmpty(data, previousData)) {\n                        return null;\n                    }\n                    if (data === previousData) {\n                        return null;\n                    }\n\n                    PerformanceUtils.logSetStateCall(subscriber, previousData, data, 'keysChanged', collectionKey);\n                    return {\n                        [subscriber.statePropertyName]: data,\n                    };\n                });\n            }\n        }\n    }\n}\n\n/**\n * When a key change happens, search for any callbacks matching the key or collection key and trigger those callbacks\n *\n * @example\n * keyChanged(key, value, subscriber => subscriber.initWithStoredValues === false)\n *\n * @private\n * @param {String} key\n * @param {*} data\n * @param {Function} [canUpdateSubscriber] only subscribers that pass this truth test will be updated\n * @param {boolean} [notifyRegularSubscibers=true]\n * @param {boolean} [notifyWithOnyxSubscibers=true]\n */\nfunction keyChanged(key, data, canUpdateSubscriber, notifyRegularSubscibers = true, notifyWithOnyxSubscibers = true) {\n    // Add or remove this key from the recentlyAccessedKeys lists\n    if (!_.isNull(data)) {\n        addLastAccessedKey(key);\n    } else {\n        removeLastAccessedKey(key);\n    }\n\n    // We are iterating over all subscribers to see if they are interested in the key that has just changed. If the subscriber's  key is a collection key then we will\n    // notify them if the key that changed is a collection member. Or if it is a regular key notify them when there is an exact match. Depending on whether the subscriber\n    // was connected via withOnyx we will call setState() directly on the withOnyx instance. If it is a regular connection we will pass the data to the provided callback.\n    const stateMappingKeys = _.keys(callbackToStateMapping);\n    for (let i = 0; i < stateMappingKeys.length; i++) {\n        const subscriber = callbackToStateMapping[stateMappingKeys[i]];\n        if (!subscriber || !isKeyMatch(subscriber.key, key) || (_.isFunction(canUpdateSubscriber) && !canUpdateSubscriber(subscriber))) {\n            continue;\n        }\n\n        // Subscriber is a regular call to connect() and provided a callback\n        if (_.isFunction(subscriber.callback)) {\n            if (!notifyRegularSubscibers) {\n                continue;\n            }\n            if (isCollectionKey(subscriber.key) && subscriber.waitForCollectionCallback) {\n                const cachedCollection = getCachedCollection(subscriber.key);\n                cachedCollection[key] = data;\n                subscriber.callback(cachedCollection);\n                continue;\n            }\n\n            subscriber.callback(data, key);\n            continue;\n        }\n\n        // Subscriber connected via withOnyx() HOC\n        if (subscriber.withOnyxInstance) {\n            if (!notifyWithOnyxSubscibers) {\n                continue;\n            }\n\n            // Check if we are subscribing to a collection key and overwrite the collection member key value in state\n            if (isCollectionKey(subscriber.key)) {\n                // If the subscriber has a selector, then the consumer of this data must only be given the data\n                // returned by the selector and only when the selected data has changed.\n                if (subscriber.selector) {\n                    subscriber.withOnyxInstance.setStateProxy((prevState) => {\n                        const prevData = prevState[subscriber.statePropertyName];\n                        const newData = {\n                            [key]: getSubsetOfData(data, subscriber.selector, subscriber.withOnyxInstance.state),\n                        };\n                        const prevDataWithNewData = {\n                            ...prevData,\n                            ...newData,\n                        };\n                        if (!deepEqual(prevData, prevDataWithNewData)) {\n                            PerformanceUtils.logSetStateCall(subscriber, prevData, newData, 'keyChanged', key);\n                            return {\n                                [subscriber.statePropertyName]: prevDataWithNewData,\n                            };\n                        }\n                        return null;\n                    });\n                    continue;\n                }\n\n                subscriber.withOnyxInstance.setStateProxy((prevState) => {\n                    const collection = prevState[subscriber.statePropertyName] || {};\n                    const newCollection = {\n                        ...collection,\n                        [key]: data,\n                    };\n                    PerformanceUtils.logSetStateCall(subscriber, collection, newCollection, 'keyChanged', key);\n                    return {\n                        [subscriber.statePropertyName]: newCollection,\n                    };\n                });\n                continue;\n            }\n\n            // If the subscriber has a selector, then the component's state must only be updated with the data\n            // returned by the selector and only if the selected data has changed.\n            if (subscriber.selector) {\n                subscriber.withOnyxInstance.setStateProxy((prevState) => {\n                    const previousValue = getSubsetOfData(prevState[subscriber.statePropertyName], subscriber.selector, subscriber.withOnyxInstance.state);\n                    const newValue = getSubsetOfData(data, subscriber.selector, subscriber.withOnyxInstance.state);\n                    if (!deepEqual(previousValue, newValue)) {\n                        return {\n                            [subscriber.statePropertyName]: newValue,\n                        };\n                    }\n                    return null;\n                });\n                continue;\n            }\n\n            // If we did not match on a collection key then we just set the new data to the state property\n            subscriber.withOnyxInstance.setStateProxy((prevState) => {\n                const previousData = prevState[subscriber.statePropertyName];\n\n                // Avoids triggering unnecessary re-renders when feeding empty objects\n                if (utils.areObjectsEmpty(data, previousData)) {\n                    return null;\n                }\n                if (previousData === data) {\n                    return null;\n                }\n\n                PerformanceUtils.logSetStateCall(subscriber, previousData, data, 'keyChanged', key);\n                return {\n                    [subscriber.statePropertyName]: data,\n                };\n            });\n            continue;\n        }\n\n        console.error('Warning: Found a matching subscriber to a key that changed, but no callback or withOnyxInstance could be found.');\n    }\n}\n\n/**\n * Sends the data obtained from the keys to the connection. It either:\n *     - sets state on the withOnyxInstances\n *     - triggers the callback function\n *\n * @private\n * @param {Object} mapping\n * @param {Object} [mapping.withOnyxInstance]\n * @param {String} [mapping.statePropertyName]\n * @param {Function} [mapping.callback]\n * @param {String} [mapping.selector]\n * @param {*|null} val\n * @param {String|undefined} matchedKey\n * @param {Boolean} isBatched\n */\nfunction sendDataToConnection(mapping, val, matchedKey, isBatched) {\n    // If the mapping no longer exists then we should not send any data.\n    // This means our subscriber disconnected or withOnyx wrapped component unmounted.\n    if (!callbackToStateMapping[mapping.connectionID]) {\n        return;\n    }\n\n    if (mapping.withOnyxInstance) {\n        let newData = val;\n\n        // If the mapping has a selector, then the component's state must only be updated with the data\n        // returned by the selector.\n        if (mapping.selector) {\n            if (isCollectionKey(mapping.key)) {\n                newData = reduceCollectionWithSelector(val, mapping.selector, mapping.withOnyxInstance.state);\n            } else {\n                newData = getSubsetOfData(val, mapping.selector, mapping.withOnyxInstance.state);\n            }\n        }\n\n        PerformanceUtils.logSetStateCall(mapping, null, newData, 'sendDataToConnection');\n        if (isBatched) {\n            batchUpdates(() => {\n                mapping.withOnyxInstance.setWithOnyxState(mapping.statePropertyName, newData);\n            });\n        } else {\n            mapping.withOnyxInstance.setWithOnyxState(mapping.statePropertyName, newData);\n        }\n        return;\n    }\n\n    if (_.isFunction(mapping.callback)) {\n        mapping.callback(val, matchedKey);\n    }\n}\n\n/**\n * We check to see if this key is flagged as safe for eviction and add it to the recentlyAccessedKeys list so that when we\n * run out of storage the least recently accessed key can be removed.\n *\n * @private\n * @param {Object} mapping\n */\nfunction addKeyToRecentlyAccessedIfNeeded(mapping) {\n    if (!isSafeEvictionKey(mapping.key)) {\n        return;\n    }\n\n    // Try to free some cache whenever we connect to a safe eviction key\n    cache.removeLeastRecentlyUsedKeys();\n\n    if (mapping.withOnyxInstance && !isCollectionKey(mapping.key)) {\n        // All React components subscribing to a key flagged as a safe eviction key must implement the canEvict property.\n        if (_.isUndefined(mapping.canEvict)) {\n            throw new Error(`Cannot subscribe to safe eviction key '${mapping.key}' without providing a canEvict value.`);\n        }\n\n        addLastAccessedKey(mapping.key);\n    }\n}\n\n/**\n * Gets the data for a given an array of matching keys, combines them into an object, and sends the result back to the subscriber.\n *\n * @private\n * @param {Array} matchingKeys\n * @param {Object} mapping\n */\nfunction getCollectionDataAndSendAsObject(matchingKeys, mapping) {\n    Promise.all(_.map(matchingKeys, (key) => get(key)))\n        .then((values) =>\n            _.reduce(\n                values,\n                (finalObject, value, i) => {\n                    // eslint-disable-next-line no-param-reassign\n                    finalObject[matchingKeys[i]] = value;\n                    return finalObject;\n                },\n                {},\n            ),\n        )\n        .then((val) => sendDataToConnection(mapping, val, undefined, true));\n}\n\n/**\n * Subscribes a react component's state directly to a store key\n *\n * @example\n * const connectionID = Onyx.connect({\n *     key: ONYXKEYS.SESSION,\n *     callback: onSessionChange,\n * });\n *\n * @param {Object} mapping the mapping information to connect Onyx to the components state\n * @param {String} mapping.key ONYXKEY to subscribe to\n * @param {String} [mapping.statePropertyName] the name of the property in the state to connect the data to\n * @param {Object} [mapping.withOnyxInstance] whose setState() method will be called with any changed data\n *      This is used by React components to connect to Onyx\n * @param {Function} [mapping.callback] a method that will be called with changed data\n *      This is used by any non-React code to connect to Onyx\n * @param {Boolean} [mapping.initWithStoredValues] If set to false, then no data will be prefilled into the\n *  component\n * @param {Boolean} [mapping.waitForCollectionCallback] If set to true, it will return the entire collection to the callback as a single object\n * @param {Function} [mapping.selector] THIS PARAM IS ONLY USED WITH withOnyx(). If included, this will be used to subscribe to a subset of an Onyx key's data.\n *       The sourceData and withOnyx state are passed to the selector and should return the simplified data. Using this setting on `withOnyx` can have very positive\n *       performance benefits because the component will only re-render when the subset of data changes. Otherwise, any change of data on any property would normally\n *       cause the component to re-render (and that can be expensive from a performance standpoint).\n * @param {String | Number | Boolean | Object} [mapping.initialValue] THIS PARAM IS ONLY USED WITH withOnyx().\n * If included, this will be passed to the component so that something can be rendered while data is being fetched from the DB.\n * Note that it will not cause the component to have the loading prop set to true. |\n * @returns {Number} an ID to use when calling disconnect\n */\nfunction connect(mapping) {\n    const connectionID = lastConnectionID++;\n    callbackToStateMapping[connectionID] = mapping;\n    callbackToStateMapping[connectionID].connectionID = connectionID;\n\n    if (mapping.initWithStoredValues === false) {\n        return connectionID;\n    }\n\n    // Commit connection only after init passes\n    deferredInitTask.promise\n        .then(() => addKeyToRecentlyAccessedIfNeeded(mapping))\n        .then(() => {\n            // Performance improvement\n            // If the mapping is connected to an onyx key that is not a collection\n            // we can skip the call to getAllKeys() and return an array with a single item\n            if (Boolean(mapping.key) && typeof mapping.key === 'string' && !mapping.key.endsWith('_') && cache.storageKeys.has(mapping.key)) {\n                return [mapping.key];\n            }\n            return getAllKeys();\n        })\n        .then((keys) => {\n            // We search all the keys in storage to see if any are a \"match\" for the subscriber we are connecting so that we\n            // can send data back to the subscriber. Note that multiple keys can match as a subscriber could either be\n            // subscribed to a \"collection key\" or a single key.\n            const matchingKeys = _.filter(keys, (key) => isKeyMatch(mapping.key, key));\n\n            // If the key being connected to does not exist we initialize the value with null. For subscribers that connected\n            // directly via connect() they will simply get a null value sent to them without any information about which key matched\n            // since there are none matched. In withOnyx() we wait for all connected keys to return a value before rendering the child\n            // component. This null value will be filtered out so that the connected component can utilize defaultProps.\n            if (matchingKeys.length === 0) {\n                if (mapping.key && !isCollectionKey(mapping.key)) {\n                    cache.set(mapping.key, null);\n                }\n\n                // Here we cannot use batching because the null value is expected to be set immediately for default props\n                // or they will be undefined.\n                sendDataToConnection(mapping, null, undefined, false);\n                return;\n            }\n\n            // When using a callback subscriber we will either trigger the provided callback for each key we find or combine all values\n            // into an object and just make a single call. The latter behavior is enabled by providing a waitForCollectionCallback key\n            // combined with a subscription to a collection key.\n            if (_.isFunction(mapping.callback)) {\n                if (isCollectionKey(mapping.key)) {\n                    if (mapping.waitForCollectionCallback) {\n                        getCollectionDataAndSendAsObject(matchingKeys, mapping);\n                        return;\n                    }\n\n                    // We did not opt into using waitForCollectionCallback mode so the callback is called for every matching key.\n                    for (let i = 0; i < matchingKeys.length; i++) {\n                        get(matchingKeys[i]).then((val) => sendDataToConnection(mapping, val, matchingKeys[i], true));\n                    }\n                    return;\n                }\n\n                // If we are not subscribed to a collection key then there's only a single key to send an update for.\n                get(mapping.key).then((val) => sendDataToConnection(mapping, val, mapping.key, true));\n                return;\n            }\n\n            // If we have a withOnyxInstance that means a React component has subscribed via the withOnyx() HOC and we need to\n            // group collection key member data into an object.\n            if (mapping.withOnyxInstance) {\n                if (isCollectionKey(mapping.key)) {\n                    getCollectionDataAndSendAsObject(matchingKeys, mapping);\n                    return;\n                }\n\n                // If the subscriber is not using a collection key then we just send a single value back to the subscriber\n                get(mapping.key).then((val) => sendDataToConnection(mapping, val, mapping.key, true));\n                return;\n            }\n\n            console.error('Warning: Onyx.connect() was found without a callback or withOnyxInstance');\n        });\n\n    // The connectionID is returned back to the caller so that it can be used to clean up the connection when it's no longer needed\n    // by calling Onyx.disconnect(connectionID).\n    return connectionID;\n}\n\n/**\n * Remove the listener for a react component\n * @example\n * Onyx.disconnect(connectionID);\n *\n * @param {Number} connectionID unique id returned by call to Onyx.connect()\n * @param {String} [keyToRemoveFromEvictionBlocklist]\n */\nfunction disconnect(connectionID, keyToRemoveFromEvictionBlocklist) {\n    if (!callbackToStateMapping[connectionID]) {\n        return;\n    }\n\n    // Remove this key from the eviction block list as we are no longer\n    // subscribing to it and it should be safe to delete again\n    if (keyToRemoveFromEvictionBlocklist) {\n        removeFromEvictionBlockList(keyToRemoveFromEvictionBlocklist, connectionID);\n    }\n\n    delete callbackToStateMapping[connectionID];\n}\n\n/**\n * Schedules an update that will be appended to the macro task queue (so it doesn't update the subscribers immediately).\n *\n * @example\n * scheduleSubscriberUpdate(key, value, subscriber => subscriber.initWithStoredValues === false)\n *\n * @param {String} key\n * @param {*} value\n * @param {Function} [canUpdateSubscriber] only subscribers that pass this truth test will be updated\n * @returns {Promise}\n */\nfunction scheduleSubscriberUpdate(key, value, canUpdateSubscriber) {\n    const promise = Promise.resolve().then(() => keyChanged(key, value, canUpdateSubscriber, true, false));\n    batchUpdates(() => keyChanged(key, value, canUpdateSubscriber, false, true));\n    return Promise.all([maybeFlushBatchUpdates(), promise]);\n}\n\n/**\n * This method is similar to notifySubscribersOnNextTick but it is built for working specifically with collections\n * so that keysChanged() is triggered for the collection and not keyChanged(). If this was not done, then the\n * subscriber callbacks receive the data in a different format than they normally expect and it breaks code.\n *\n * @param {String} key\n * @param {*} value\n * @returns {Promise}\n */\nfunction scheduleNotifyCollectionSubscribers(key, value) {\n    const promise = Promise.resolve().then(() => keysChanged(key, value, true, false));\n    batchUpdates(() => keysChanged(key, value, false, true));\n    return Promise.all([maybeFlushBatchUpdates(), promise]);\n}\n\n/**\n * Remove a key from Onyx and update the subscribers\n *\n * @private\n * @param {String} key\n * @return {Promise}\n */\nfunction remove(key) {\n    cache.drop(key);\n    scheduleSubscriberUpdate(key, null);\n    return Storage.removeItem(key);\n}\n\n/**\n * @private\n * @returns {Promise<void>}\n */\nfunction reportStorageQuota() {\n    return Storage.getDatabaseSize()\n        .then(({bytesUsed, bytesRemaining}) => {\n            Logger.logInfo(`Storage Quota Check -- bytesUsed: ${bytesUsed} bytesRemaining: ${bytesRemaining}`);\n        })\n        .catch((dbSizeError) => {\n            Logger.logAlert(`Unable to get database size. Error: ${dbSizeError}`);\n        });\n}\n\n/**\n * If we fail to set or merge we must handle this by\n * evicting some data from Onyx and then retrying to do\n * whatever it is we attempted to do.\n *\n * @private\n * @param {Error} error\n * @param {Function} onyxMethod\n * @param  {...any} args\n * @return {Promise}\n */\nfunction evictStorageAndRetry(error, onyxMethod, ...args) {\n    Logger.logInfo(`Failed to save to storage. Error: ${error}. onyxMethod: ${onyxMethod.name}`);\n\n    if (error && Str.startsWith(error.message, \"Failed to execute 'put' on 'IDBObjectStore'\")) {\n        Logger.logAlert('Attempted to set invalid data set in Onyx. Please ensure all data is serializable.');\n        throw error;\n    }\n\n    // Find the first key that we can remove that has no subscribers in our blocklist\n    const keyForRemoval = _.find(recentlyAccessedKeys, (key) => !evictionBlocklist[key]);\n    if (!keyForRemoval) {\n        // If we have no acceptable keys to remove then we are possibly trying to save mission critical data. If this is the case,\n        // then we should stop retrying as there is not much the user can do to fix this. Instead of getting them stuck in an infinite loop we\n        // will allow this write to be skipped.\n        Logger.logAlert('Out of storage. But found no acceptable keys to remove.');\n        return reportStorageQuota();\n    }\n\n    // Remove the least recently viewed key that is not currently being accessed and retry.\n    Logger.logInfo(`Out of storage. Evicting least recently accessed key (${keyForRemoval}) and retrying.`);\n    reportStorageQuota();\n    return remove(keyForRemoval).then(() => onyxMethod(...args));\n}\n\n/**\n * Notifys subscribers and writes current value to cache\n *\n * @param {String} key\n * @param {*} value\n * @param {String} method\n * @param {Boolean} hasChanged\n * @param {Boolean} wasRemoved\n * @returns {Promise}\n */\nfunction broadcastUpdate(key, value, method, hasChanged, wasRemoved = false) {\n    // Logging properties only since values could be sensitive things we don't want to log\n    Logger.logInfo(`${method}() called for key: ${key}${_.isObject(value) ? ` properties: ${_.keys(value).join(',')}` : ''}`);\n\n    // Update subscribers if the cached value has changed, or when the subscriber specifically requires\n    // all updates regardless of value changes (indicated by initWithStoredValues set to false).\n    if (hasChanged && !wasRemoved) {\n        cache.set(key, value);\n    } else {\n        cache.addToAccessedKeys(key);\n    }\n\n    return scheduleSubscriberUpdate(key, value, (subscriber) => hasChanged || subscriber.initWithStoredValues === false);\n}\n\n/**\n * @param {String} key\n * @returns {Boolean}\n */\nfunction hasPendingMergeForKey(key) {\n    return Boolean(mergeQueue[key]);\n}\n\n/**\n * Removes a key from storage if the value is null.\n * Otherwise removes all nested null values in objects and returns the object\n * @param {String} key\n * @param {Mixed} value\n * @returns {Mixed} The value without null values and a boolean \"wasRemoved\", which indicates if the key got removed completely\n */\nfunction removeNullValues(key, value) {\n    if (_.isNull(value)) {\n        remove(key);\n        return {value, wasRemoved: true};\n    }\n\n    // We can remove all null values in an object by merging it with itself\n    // utils.fastMerge recursively goes through the object and removes all null values\n    // Passing two identical objects as source and target to fastMerge will not change it, but only remove the null values\n    return {value: utils.removeNestedNullValues(value), wasRemoved: false};\n}\n\n/**\n * Write a value to our store with the given key\n *\n * @param {String} key ONYXKEY to set\n * @param {*} value value to store\n *\n * @returns {Promise}\n */\nfunction set(key, value) {\n    if (!ActiveClientManager.isClientTheLeader()) {\n        Broadcast.sendMessage({type: METHOD.SET, key, value});\n        return Promise.resolve();\n    }\n\n    if (isClearing) {\n        return Promise.resolve();\n    }\n\n    // If the value is null, we remove the key from storage\n    const {value: valueAfterRemoving, wasRemoved} = removeNullValues(key, value);\n\n    if (hasPendingMergeForKey(key)) {\n        delete mergeQueue[key];\n    }\n\n    const hasChanged = cache.hasValueChanged(key, valueAfterRemoving);\n\n    // This approach prioritizes fast UI changes without waiting for data to be stored in device storage.\n    const updatePromise = broadcastUpdate(key, valueAfterRemoving, 'set', hasChanged, wasRemoved);\n\n    // If the value has not changed or the key got removed, calling Storage.setItem() would be redundant and a waste of performance, so return early instead.\n    if (!hasChanged || wasRemoved) {\n        return updatePromise;\n    }\n\n    return Storage.setItem(key, valueAfterRemoving)\n        .catch((error) => evictStorageAndRetry(error, set, key, valueAfterRemoving))\n        .then(() => updatePromise);\n}\n\n/**\n * Storage expects array like: [[\"@MyApp_user\", value_1], [\"@MyApp_key\", value_2]]\n * This method transforms an object like {'@MyApp_user': myUserValue, '@MyApp_key': myKeyValue}\n * to an array of key-value pairs in the above format and removes key-value pairs that are being set to null\n * @private\n * @param {Record} data\n * @return {Array} an array of key - value pairs <[key, value]>\n */\nfunction prepareKeyValuePairsForStorage(data) {\n    const keyValuePairs = [];\n\n    _.forEach(data, (value, key) => {\n        const {value: valueAfterRemoving, wasRemoved} = removeNullValues(key, value);\n\n        if (wasRemoved) return;\n\n        keyValuePairs.push([key, valueAfterRemoving]);\n    });\n\n    return keyValuePairs;\n}\n\n/**\n * Sets multiple keys and values\n *\n * @example Onyx.multiSet({'key1': 'a', 'key2': 'b'});\n *\n * @param {Object} data object keyed by ONYXKEYS and the values to set\n * @returns {Promise}\n */\nfunction multiSet(data) {\n    if (!ActiveClientManager.isClientTheLeader()) {\n        Broadcast.sendMessage({type: METHOD.MULTI_SET, data});\n        return Promise.resolve();\n    }\n\n    if (isClearing) {\n        return Promise.resolve();\n    }\n\n    const keyValuePairs = prepareKeyValuePairsForStorage(data);\n\n    const updatePromises = _.map(keyValuePairs, ([key, value]) => {\n        // Update cache and optimistically inform subscribers on the next tick\n        cache.set(key, value);\n        return scheduleSubscriberUpdate(key, value);\n    });\n\n    return Storage.multiSet(keyValuePairs)\n        .catch((error) => evictStorageAndRetry(error, multiSet, data))\n        .then(() => Promise.all(updatePromises));\n}\n\n/**\n * Merges an array of changes with an existing value\n *\n * @private\n * @param {*} existingValue\n * @param {Array<*>} changes Array of changes that should be applied to the existing value\n * @param {Boolean} shouldRemoveNullObjectValues\n * @returns {*}\n */\nfunction applyMerge(existingValue, changes, shouldRemoveNullObjectValues) {\n    const lastChange = _.last(changes);\n\n    if (_.isArray(lastChange)) {\n        return lastChange;\n    }\n\n    if (_.some(changes, _.isObject)) {\n        // Object values are then merged one after the other\n        return _.reduce(changes, (modifiedData, change) => utils.fastMerge(modifiedData, change, shouldRemoveNullObjectValues), existingValue || {});\n    }\n\n    // If we have anything else we can't merge it so we'll\n    // simply return the last value that was queued\n    return lastChange;\n}\n\n/**\n * Merge a new value into an existing value at a key.\n *\n * The types of values that can be merged are `Object` and `Array`. To set another type of value use `Onyx.set()`.\n * Values of type `Object` get merged with the old value, whilst for `Array`'s we simply replace the current value with the new one.\n *\n * Calls to `Onyx.merge()` are batched so that any calls performed in a single tick will stack in a queue and get\n * applied in the order they were called. Note: `Onyx.set()` calls do not work this way so use caution when mixing\n * `Onyx.merge()` and `Onyx.set()`.\n *\n * @example\n * Onyx.merge(ONYXKEYS.EMPLOYEE_LIST, ['Joe']); // -> ['Joe']\n * Onyx.merge(ONYXKEYS.EMPLOYEE_LIST, ['Jack']); // -> ['Joe', 'Jack']\n * Onyx.merge(ONYXKEYS.POLICY, {id: 1}); // -> {id: 1}\n * Onyx.merge(ONYXKEYS.POLICY, {name: 'My Workspace'}); // -> {id: 1, name: 'My Workspace'}\n *\n * @param {String} key ONYXKEYS key\n * @param {(Object|Array)} changes Object or Array value to merge\n * @returns {Promise}\n */\nfunction merge(key, changes) {\n    if (!ActiveClientManager.isClientTheLeader()) {\n        Broadcast.sendMessage({type: METHOD.MERGE, key, changes});\n        return Promise.resolve();\n    }\n\n    if (isClearing) {\n        return Promise.resolve();\n    }\n\n    // Top-level undefined values are ignored\n    // Therefore we need to prevent adding them to the merge queue\n    if (_.isUndefined(changes)) {\n        return mergeQueue[key] ? mergeQueuePromise[key] : Promise.resolve();\n    }\n\n    // Merge attempts are batched together. The delta should be applied after a single call to get() to prevent a race condition.\n    // Using the initial value from storage in subsequent merge attempts will lead to an incorrect final merged value.\n    if (mergeQueue[key]) {\n        mergeQueue[key].push(changes);\n        return mergeQueuePromise[key];\n    }\n    mergeQueue[key] = [changes];\n\n    mergeQueuePromise[key] = get(key).then((existingValue) => {\n        // Calls to Onyx.set after a merge will terminate the current merge process and clear the merge queue\n        if (mergeQueue[key] == null) return;\n\n        try {\n            // We first only merge the changes, so we can provide these to the native implementation (SQLite uses only delta changes in \"JSON_PATCH\" to merge)\n            // We don't want to remove null values from the \"batchedChanges\", because SQLite uses them to remove keys from storage natively.\n            let batchedChanges = applyMerge(undefined, mergeQueue[key], false);\n\n            // The presence of a `null` in the merge queue instructs us to drop the existing value.\n            // In this case, we can't simply merge the batched changes with the existing value, because then the null in the merge queue would have no effect\n            const shouldOverwriteExistingValue = _.includes(mergeQueue[key], null);\n\n            // Clean up the write queue, so we don't apply these changes again\n            delete mergeQueue[key];\n            delete mergeQueuePromise[key];\n\n            // If the batched changes equal null, we want to remove the key from storage, to reduce storage size\n            const {wasRemoved} = removeNullValues(key, batchedChanges);\n\n            // After that we merge the batched changes with the existing value\n            // We can remove null values from the \"modifiedData\", because \"null\" implicates that the user wants to remove a value from storage.\n            // The \"modifiedData\" will be directly \"set\" in storage instead of being merged\n            const modifiedData = shouldOverwriteExistingValue ? batchedChanges : applyMerge(existingValue, [batchedChanges], true);\n\n            // On native platforms we use SQLite which utilises JSON_PATCH to merge changes.\n            // JSON_PATCH generally removes null values from the stored object.\n            // When there is no existing value though, SQLite will just insert the changes as a new value and thus the null values won't be removed.\n            // Therefore we need to remove null values from the `batchedChanges` which are sent to the SQLite, if no existing value is present.\n            if (!existingValue) {\n                batchedChanges = applyMerge(undefined, [batchedChanges], true);\n            }\n\n            const hasChanged = cache.hasValueChanged(key, modifiedData);\n\n            // This approach prioritizes fast UI changes without waiting for data to be stored in device storage.\n            const updatePromise = broadcastUpdate(key, modifiedData, 'merge', hasChanged, wasRemoved);\n\n            // If the value has not changed, calling Storage.setItem() would be redundant and a waste of performance, so return early instead.\n            if (!hasChanged || isClearing || wasRemoved) {\n                return updatePromise;\n            }\n\n            return Storage.mergeItem(key, batchedChanges, modifiedData).then(() => updatePromise);\n        } catch (error) {\n            Logger.logAlert(`An error occurred while applying merge for key: ${key}, Error: ${error}`);\n            return Promise.resolve();\n        }\n    });\n\n    return mergeQueuePromise[key];\n}\n\n/**\n * Merge user provided default key value pairs.\n * @private\n * @returns {Promise}\n */\nfunction initializeWithDefaultKeyStates() {\n    return Storage.multiGet(_.keys(defaultKeyStates)).then((pairs) => {\n        const asObject = _.object(pairs);\n\n        const merged = utils.fastMerge(asObject, defaultKeyStates);\n        cache.merge(merged);\n        _.each(merged, (val, key) => keyChanged(key, val));\n    });\n}\n\n/**\n * Clear out all the data in the store\n *\n * Note that calling Onyx.clear() and then Onyx.set() on a key with a default\n * key state may store an unexpected value in Storage.\n *\n * E.g.\n * Onyx.clear();\n * Onyx.set(ONYXKEYS.DEFAULT_KEY, 'default');\n * Storage.getItem(ONYXKEYS.DEFAULT_KEY)\n *     .then((storedValue) => console.log(storedValue));\n * null is logged instead of the expected 'default'\n *\n * Onyx.set() might call Storage.setItem() before Onyx.clear() calls\n * Storage.setItem(). Use Onyx.merge() instead if possible. Onyx.merge() calls\n * Onyx.get(key) before calling Storage.setItem() via Onyx.set().\n * Storage.setItem() from Onyx.clear() will have already finished and the merged\n * value will be saved to storage after the default value.\n *\n * @param {Array} keysToPreserve is a list of ONYXKEYS that should not be cleared with the rest of the data\n * @returns {Promise<void>}\n */\nfunction clear(keysToPreserve = []) {\n    if (!ActiveClientManager.isClientTheLeader()) {\n        Broadcast.sendMessage({type: METHOD.CLEAR, keysToPreserve});\n        return Promise.resolve();\n    }\n\n    if (isClearing) {\n        return Promise.resolve();\n    }\n\n    isClearing = true;\n\n    return getAllKeys().then((keys) => {\n        const keysToBeClearedFromStorage = [];\n        const keyValuesToResetAsCollection = {};\n        const keyValuesToResetIndividually = {};\n\n        // The only keys that should not be cleared are:\n        // 1. Anything specifically passed in keysToPreserve (because some keys like language preferences, offline\n        //      status, or activeClients need to remain in Onyx even when signed out)\n        // 2. Any keys with a default state (because they need to remain in Onyx as their default, and setting them\n        //      to null would cause unknown behavior)\n        _.each(keys, (key) => {\n            const isKeyToPreserve = _.contains(keysToPreserve, key);\n            const isDefaultKey = _.has(defaultKeyStates, key);\n\n            // If the key is being removed or reset to default:\n            // 1. Update it in the cache\n            // 2. Figure out whether it is a collection key or not,\n            //      since collection key subscribers need to be updated differently\n            if (!isKeyToPreserve) {\n                const oldValue = cache.getValue(key);\n                const newValue = _.get(defaultKeyStates, key, null);\n                if (newValue !== oldValue) {\n                    cache.set(key, newValue);\n                    const collectionKey = key.substring(0, key.indexOf('_') + 1);\n                    if (collectionKey) {\n                        if (!keyValuesToResetAsCollection[collectionKey]) {\n                            keyValuesToResetAsCollection[collectionKey] = {};\n                        }\n                        keyValuesToResetAsCollection[collectionKey][key] = newValue;\n                    } else {\n                        keyValuesToResetIndividually[key] = newValue;\n                    }\n                }\n            }\n\n            if (isKeyToPreserve || isDefaultKey) {\n                return;\n            }\n\n            // If it isn't preserved and doesn't have a default, we'll remove it\n            keysToBeClearedFromStorage.push(key);\n        });\n\n        const updatePromises = [];\n\n        // Notify the subscribers for each key/value group so they can receive the new values\n        _.each(keyValuesToResetIndividually, (value, key) => {\n            updatePromises.push(scheduleSubscriberUpdate(key, value));\n        });\n        _.each(keyValuesToResetAsCollection, (value, key) => {\n            updatePromises.push(scheduleNotifyCollectionSubscribers(key, value));\n        });\n\n        const defaultKeyValuePairs = _.pairs(_.omit(defaultKeyStates, keysToPreserve));\n\n        // Remove only the items that we want cleared from storage, and reset others to default\n        _.each(keysToBeClearedFromStorage, (key) => cache.drop(key));\n        return Storage.removeItems(keysToBeClearedFromStorage)\n            .then(() => Storage.multiSet(defaultKeyValuePairs))\n            .then(() => {\n                isClearing = false;\n                Broadcast.sendMessage({type: METHOD.CLEAR, keysToPreserve});\n                return Promise.all(updatePromises);\n            });\n    });\n}\n\n/**\n * Merges a collection based on their keys\n *\n * @example\n *\n * Onyx.mergeCollection(ONYXKEYS.COLLECTION.REPORT, {\n *     [`${ONYXKEYS.COLLECTION.REPORT}1`]: report1,\n *     [`${ONYXKEYS.COLLECTION.REPORT}2`]: report2,\n * });\n *\n * @param {String} collectionKey e.g. `ONYXKEYS.COLLECTION.REPORT`\n * @param {Object} collection Object collection keyed by individual collection member keys and values\n * @returns {Promise}\n */\nfunction mergeCollection(collectionKey, collection) {\n    if (!_.isObject(collection) || _.isArray(collection) || _.isEmpty(collection)) {\n        Logger.logInfo('mergeCollection() called with invalid or empty value. Skipping this update.');\n        return Promise.resolve();\n    }\n\n    // Confirm all the collection keys belong to the same parent\n    let hasCollectionKeyCheckFailed = false;\n    _.each(collection, (_data, dataKey) => {\n        if (isKeyMatch(collectionKey, dataKey)) {\n            return;\n        }\n\n        if (process.env.NODE_ENV === 'development') {\n            throw new Error(`Provided collection doesn't have all its data belonging to the same parent. CollectionKey: ${collectionKey}, DataKey: ${dataKey}`);\n        }\n\n        hasCollectionKeyCheckFailed = true;\n        Logger.logAlert(`Provided collection doesn't have all its data belonging to the same parent. CollectionKey: ${collectionKey}, DataKey: ${dataKey}`);\n    });\n\n    // Gracefully handle bad mergeCollection updates so it doesn't block the merge queue\n    if (hasCollectionKeyCheckFailed) {\n        return Promise.resolve();\n    }\n\n    return getAllKeys().then((persistedKeys) => {\n        // Split to keys that exist in storage and keys that don't\n        const [existingKeys, newKeys] = _.chain(collection)\n            .pick((value, key) => {\n                if (_.isNull(value)) {\n                    remove(key);\n                    return false;\n                }\n                return true;\n            })\n            .keys()\n            .partition((key) => persistedKeys.includes(key))\n            .value();\n\n        const existingKeyCollection = _.pick(collection, existingKeys);\n        const newCollection = _.pick(collection, newKeys);\n        const keyValuePairsForExistingCollection = prepareKeyValuePairsForStorage(existingKeyCollection);\n        const keyValuePairsForNewCollection = prepareKeyValuePairsForStorage(newCollection);\n\n        const promises = [];\n\n        // New keys will be added via multiSet while existing keys will be updated using multiMerge\n        // This is because setting a key that doesn't exist yet with multiMerge will throw errors\n        if (keyValuePairsForExistingCollection.length > 0) {\n            promises.push(Storage.multiMerge(keyValuePairsForExistingCollection));\n        }\n\n        if (keyValuePairsForNewCollection.length > 0) {\n            promises.push(Storage.multiSet(keyValuePairsForNewCollection));\n        }\n\n        // Prefill cache if necessary by calling get() on any existing keys and then merge original data to cache\n        // and update all subscribers\n        const promiseUpdate = Promise.all(_.map(existingKeys, get)).then(() => {\n            cache.merge(collection);\n            return scheduleNotifyCollectionSubscribers(collectionKey, collection);\n        });\n\n        return Promise.all(promises)\n            .catch((error) => evictStorageAndRetry(error, mergeCollection, collection))\n            .then(() => promiseUpdate);\n    });\n}\n\n/**\n * Insert API responses and lifecycle data into Onyx\n *\n * @param {Array} data An array of objects with shape {onyxMethod: oneOf('set', 'merge', 'mergeCollection', 'multiSet', 'clear'), key: string, value: *}\n * @returns {Promise} resolves when all operations are complete\n */\nfunction update(data) {\n    // First, validate the Onyx object is in the format we expect\n    _.each(data, ({onyxMethod, key, value}) => {\n        if (!_.contains([METHOD.CLEAR, METHOD.SET, METHOD.MERGE, METHOD.MERGE_COLLECTION, METHOD.MULTI_SET], onyxMethod)) {\n            throw new Error(`Invalid onyxMethod ${onyxMethod} in Onyx update.`);\n        }\n        if (onyxMethod === METHOD.MULTI_SET) {\n            // For multiset, we just expect the value to be an object\n            if (!_.isObject(value) || _.isArray(value) || _.isFunction(value)) {\n                throw new Error('Invalid value provided in Onyx multiSet. Onyx multiSet value must be of type object.');\n            }\n        } else if (onyxMethod !== METHOD.CLEAR && !_.isString(key)) {\n            throw new Error(`Invalid ${typeof key} key provided in Onyx update. Onyx key must be of type string.`);\n        }\n    });\n\n    const promises = [];\n    let clearPromise = Promise.resolve();\n\n    _.each(data, ({onyxMethod, key, value}) => {\n        switch (onyxMethod) {\n            case METHOD.SET:\n                promises.push(() => set(key, value));\n                break;\n            case METHOD.MERGE:\n                promises.push(() => merge(key, value));\n                break;\n            case METHOD.MERGE_COLLECTION:\n                promises.push(() => mergeCollection(key, value));\n                break;\n            case METHOD.MULTI_SET:\n                promises.push(() => multiSet(value));\n                break;\n            case METHOD.CLEAR:\n                clearPromise = clear();\n                break;\n            default:\n                break;\n        }\n    });\n\n    return clearPromise.then(() => Promise.all(_.map(promises, (p) => p())));\n}\n\n/**\n * When set these keys will not be persisted to storage\n * @param {string[]} keyList\n */\nfunction setMemoryOnlyKeys(keyList) {\n    Storage.setMemoryOnlyKeys(keyList);\n\n    // When in memory only mode for certain keys we do not want to ever drop items from the cache as the user will have no way to recover them again via storage.\n    cache.setRecentKeysLimit(Infinity);\n}\n\n/**\n * Sets the callback to be called when the clear finishes executing.\n * @param {Function} callback\n */\nfunction onClear(callback) {\n    onClearCallback = callback;\n}\n\n/**\n * Subscribes to the Broadcast channel and executes actions based on the\n * types of events.\n */\nfunction subscribeToEvents() {\n    Broadcast.subscribe(({data}) => {\n        if (!ActiveClientManager.isClientTheLeader()) {\n            return;\n        }\n        switch (data.type) {\n            case METHOD.CLEAR:\n                clear(data.keysToPreserve);\n                break;\n            case METHOD.SET:\n                set(data.key, data.value);\n                break;\n            case METHOD.MULTI_SET:\n                multiSet(data.key, data.value);\n                break;\n            case METHOD.MERGE:\n                merge(data.key, data.changes);\n                break;\n            case ON_CLEAR:\n                if (!onClearCallback) {\n                    break;\n                }\n                onClearCallback();\n                break;\n            default:\n                break;\n        }\n    });\n}\n\n/**\n * Initialize the store with actions and listening for storage events\n *\n * @param {Object} [options={}] config object\n * @param {Object} [options.keys={}] `ONYXKEYS` constants object\n * @param {Object} [options.initialKeyStates={}] initial data to set when `init()` and `clear()` is called\n * @param {String[]} [options.safeEvictionKeys=[]] This is an array of keys\n * (individual or collection patterns) that when provided to Onyx are flagged\n * as \"safe\" for removal. Any components subscribing to these keys must also\n * implement a canEvict option. See the README for more info.\n * @param {Number} [options.maxCachedKeysCount=55] Sets how many recent keys should we try to keep in cache\n * Setting this to 0 would practically mean no cache\n * We try to free cache when we connect to a safe eviction key\n * @param {Boolean} [options.captureMetrics] Enables Onyx benchmarking and exposes the get/print/reset functions\n * @param {Boolean} [options.shouldSyncMultipleInstances] Auto synchronize storage events between multiple instances\n * of Onyx running in different tabs/windows. Defaults to true for platforms that support local storage (web/desktop)\n * @param {Boolean} [options.debugSetState] Enables debugging setState() calls to connected components.\n * @example\n * Onyx.init({\n *     keys: ONYXKEYS,\n *     initialKeyStates: {\n *         [ONYXKEYS.SESSION]: {loading: false},\n *     },\n * });\n */\nfunction init({\n    keys = {},\n    initialKeyStates = {},\n    safeEvictionKeys = [],\n    maxCachedKeysCount = 1000,\n    captureMetrics = false,\n    shouldSyncMultipleInstances = Boolean(global.localStorage),\n    debugSetState = false,\n} = {}) {\n    ActiveClientManager.init();\n\n    ActiveClientManager.isReady().then(() => {\n        if (!ActiveClientManager.isClientTheLeader()) {\n            return;\n        }\n        subscribeToEvents();\n    });\n\n    if (captureMetrics) {\n        // The code here is only bundled and applied when the captureMetrics is set\n        // eslint-disable-next-line no-use-before-define\n        applyDecorators();\n    }\n\n    if (debugSetState) {\n        PerformanceUtils.setShouldDebugSetState(true);\n    }\n\n    if (maxCachedKeysCount > 0) {\n        cache.setRecentKeysLimit(maxCachedKeysCount);\n    }\n\n    // We need the value of the collection keys later for checking if a\n    // key is a collection. We store it in a map for faster lookup.\n    const collectionValues = _.values(keys.COLLECTION);\n    onyxCollectionKeyMap = _.reduce(\n        collectionValues,\n        (acc, val) => {\n            acc.set(val, true);\n            return acc;\n        },\n        new Map(),\n    );\n\n    // Set our default key states to use when initializing and clearing Onyx data\n    defaultKeyStates = initialKeyStates;\n\n    // Let Onyx know about which keys are safe to evict\n    evictionAllowList = safeEvictionKeys;\n\n    // Initialize all of our keys with data provided then give green light to any pending connections\n    Promise.all([addAllSafeEvictionKeysToRecentlyAccessedList(), initializeWithDefaultKeyStates()]).then(deferredInitTask.resolve);\n\n    if (shouldSyncMultipleInstances && _.isFunction(Storage.keepInstancesSync)) {\n        Storage.keepInstancesSync((key, value) => {\n            cache.set(key, value);\n            keyChanged(key, value);\n        });\n    }\n}\n\nconst Onyx = {\n    connect,\n    disconnect,\n    set,\n    multiSet,\n    merge,\n    mergeCollection,\n    update,\n    clear,\n    getAllKeys,\n    init,\n    registerLogger: Logger.registerLogger,\n    addToEvictionBlockList,\n    removeFromEvictionBlockList,\n    isSafeEvictionKey,\n    METHOD,\n    setMemoryOnlyKeys,\n    tryGetCachedValue,\n    hasPendingMergeForKey,\n    onClear,\n    isClientManagerReady: ActiveClientManager.isReady,\n    isClientTheLeader: ActiveClientManager.isClientTheLeader,\n    subscribeToClientChange: ActiveClientManager.subscribeToClientChange,\n};\n\n/**\n * Apply calls statistic decorators to benchmark Onyx\n *\n * @private\n */\nfunction applyDecorators() {\n    // We're requiring the script dynamically here so that it's only evaluated when decorators are used\n    const decorate = require('./metrics');\n\n    // Re-assign with decorated functions\n    /* eslint-disable no-func-assign */\n    get = decorate.decorateWithMetrics(get, 'Onyx:get');\n    set = decorate.decorateWithMetrics(set, 'Onyx:set');\n    multiSet = decorate.decorateWithMetrics(multiSet, 'Onyx:multiSet');\n    clear = decorate.decorateWithMetrics(clear, 'Onyx:clear');\n    merge = decorate.decorateWithMetrics(merge, 'Onyx:merge');\n    mergeCollection = decorate.decorateWithMetrics(mergeCollection, 'Onyx:mergeCollection');\n    getAllKeys = decorate.decorateWithMetrics(getAllKeys, 'Onyx:getAllKeys');\n    initializeWithDefaultKeyStates = decorate.decorateWithMetrics(initializeWithDefaultKeyStates, 'Onyx:defaults');\n    update = decorate.decorateWithMetrics(update, 'Onyx:update');\n    /* eslint-enable */\n\n    // Re-expose decorated methods\n    /* eslint-disable rulesdir/prefer-actions-set-data */\n    Onyx.set = set;\n    Onyx.multiSet = multiSet;\n    Onyx.clear = clear;\n    Onyx.merge = merge;\n    Onyx.mergeCollection = mergeCollection;\n    Onyx.update = update;\n    /* eslint-enable */\n\n    // Expose stats methods on Onyx\n    Onyx.getMetrics = decorate.getMetrics;\n    Onyx.resetMetrics = decorate.resetMetrics;\n    Onyx.printMetrics = decorate.printMetrics;\n}\n\nexport default Onyx;\n","/**\n * Create a deferred task that can be resolved when we call `resolve()`\n * The returned promise will complete when we call `resolve`\n * Useful when we want to wait for a tasks that is resolved from an external action\n *\n * @template T\n * @returns {{ resolve: function(*), promise: Promise<T|void> }}\n */\nexport default function createDeferredTask() {\n    const deferred = {};\n    deferred.promise = new Promise((res) => {\n        deferred.resolve = res;\n    });\n\n    return deferred;\n}\n","/**\n * This is a higher order component that provides the ability to map a state property directly to\n * something in Onyx (a key/value store). That way, as soon as data in Onyx changes, the state will be set and the view\n * will automatically change to reflect the new data.\n */\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport _ from 'underscore';\nimport Onyx from './Onyx';\nimport * as Str from './Str';\nimport utils from './utils';\n\n// This is a list of keys that can exist on a `mapping`, but are not directly related to loading data from Onyx. When the keys of a mapping are looped over to check\n// if a key has changed, it's a good idea to skip looking at these properties since they would have unexpected results.\nconst mappingPropertiesToIgnoreChangesTo = ['initialValue', 'allowStaleData'];\n\n/**\n * Returns the display name of a component\n *\n * @param {object} component\n * @returns {string}\n */\nfunction getDisplayName(component) {\n    return component.displayName || component.name || 'Component';\n}\n\n/**\n * Removes all the keys from state that are unrelated to the onyx data being mapped to the component.\n *\n * @param {Object} state of the component\n * @param {Object} onyxToStateMapping the object holding all of the mapping configuration for the component\n * @returns {Object}\n */\nconst getOnyxDataFromState = (state, onyxToStateMapping) => _.pick(state, _.keys(onyxToStateMapping));\n\nexport default function (mapOnyxToState, shouldDelayUpdates = false) {\n    // A list of keys that must be present in tempState before we can render the WrappedComponent\n    const requiredKeysForInit = _.chain(mapOnyxToState)\n        .omit((config) => config.initWithStoredValues === false)\n        .keys()\n        .value();\n    return (WrappedComponent) => {\n        const displayName = getDisplayName(WrappedComponent);\n        class withOnyx extends React.Component {\n            pendingSetStates = [];\n\n            constructor(props) {\n                super(props);\n                this.shouldDelayUpdates = shouldDelayUpdates;\n                this.setWithOnyxState = this.setWithOnyxState.bind(this);\n                this.flushPendingSetStates = this.flushPendingSetStates.bind(this);\n\n                // This stores all the Onyx connection IDs to be used when the component unmounts so everything can be\n                // disconnected. It is a key value store with the format {[mapping.key]: connectionID}.\n                this.activeConnectionIDs = {};\n\n                const cachedState = _.reduce(\n                    mapOnyxToState,\n                    (resultObj, mapping, propertyName) => {\n                        const key = Str.result(mapping.key, props);\n                        let value = Onyx.tryGetCachedValue(key, mapping);\n                        if (!value && mapping.initialValue) {\n                            value = mapping.initialValue;\n                        }\n\n                        /**\n                         * If we have a pending merge for a key it could mean that data is being set via Onyx.merge() and someone expects a component to have this data immediately.\n                         *\n                         * @example\n                         *\n                         * Onyx.merge('report_123', value);\n                         * Navigation.navigate(route); // Where \"route\" expects the \"value\" to be available immediately once rendered.\n                         *\n                         * In reality, Onyx.merge() will only update the subscriber after all merges have been batched and the previous value is retrieved via a get() (returns a promise).\n                         * So, we won't use the cache optimization here as it will lead us to arbitrarily defer various actions in the application code.\n                         */\n                        if ((value !== undefined && !Onyx.hasPendingMergeForKey(key)) || mapping.allowStaleData) {\n                            // eslint-disable-next-line no-param-reassign\n                            resultObj[propertyName] = value;\n                        }\n\n                        return resultObj;\n                    },\n                    {},\n                );\n\n                // If we have all the data we need, then we can render the component immediately\n                cachedState.loading = _.size(cachedState) < requiredKeysForInit.length;\n\n                // Object holding the temporary initial state for the component while we load the various Onyx keys\n                this.tempState = cachedState;\n\n                this.state = cachedState;\n            }\n\n            componentDidMount() {\n                const onyxDataFromState = getOnyxDataFromState(this.state, mapOnyxToState);\n\n                // Subscribe each of the state properties to the proper Onyx key\n                _.each(mapOnyxToState, (mapping, propertyName) => {\n                    if (_.includes(mappingPropertiesToIgnoreChangesTo, propertyName)) {\n                        return;\n                    }\n                    const key = Str.result(mapping.key, {...this.props, ...onyxDataFromState});\n                    this.connectMappingToOnyx(mapping, propertyName, key);\n                });\n                this.checkEvictableKeys();\n            }\n\n            componentDidUpdate(prevProps, prevState) {\n                // The whole purpose of this method is to check to see if a key that is subscribed to Onyx has changed, and then Onyx needs to be disconnected from the old\n                // key and connected to the new key.\n                // For example, a key could change if KeyB depends on data loading from Onyx for KeyA.\n                const isFirstTimeUpdatingAfterLoading = prevState.loading && !this.state.loading;\n                const onyxDataFromState = getOnyxDataFromState(this.state, mapOnyxToState);\n                const prevOnyxDataFromState = getOnyxDataFromState(prevState, mapOnyxToState);\n\n                _.each(mapOnyxToState, (mapping, propName) => {\n                    // Some properties can be ignored because they aren't related to onyx keys and they will never change\n                    if (_.includes(mappingPropertiesToIgnoreChangesTo, propName)) {\n                        return;\n                    }\n\n                    // The previous key comes from either:\n                    // 1) The initial key that was connected to (ie. set from `componentDidMount()`)\n                    // 2) The updated props which caused `componentDidUpdate()` to run\n                    // The first case cannot be used all the time because of race conditions where `componentDidUpdate()` can be triggered before connectingMappingToOnyx() is done\n                    // (eg. if a user switches chats really quickly). In this case, it's much more stable to always look at the changes to prevProp and prevState to derive the key.\n                    // The second case cannot be used all the time because the onyx data doesn't change the first time that `componentDidUpdate()` runs after loading. In this case,\n                    // the `mapping.previousKey` must be used for the comparison or else this logic never detects that onyx data could have changed during the loading process.\n                    const previousKey = isFirstTimeUpdatingAfterLoading ? mapping.previousKey : Str.result(mapping.key, {...prevProps, ...prevOnyxDataFromState});\n                    const newKey = Str.result(mapping.key, {...this.props, ...onyxDataFromState});\n                    if (previousKey !== newKey) {\n                        Onyx.disconnect(this.activeConnectionIDs[previousKey], previousKey);\n                        delete this.activeConnectionIDs[previousKey];\n                        this.connectMappingToOnyx(mapping, propName, newKey);\n                    }\n                });\n                this.checkEvictableKeys();\n            }\n\n            componentWillUnmount() {\n                // Disconnect everything from Onyx\n                _.each(mapOnyxToState, (mapping) => {\n                    const key = Str.result(mapping.key, {...this.props, ...getOnyxDataFromState(this.state, mapOnyxToState)});\n                    Onyx.disconnect(this.activeConnectionIDs[key], key);\n                });\n            }\n\n            setStateProxy(modifier) {\n                if (this.shouldDelayUpdates) {\n                    this.pendingSetStates.push(modifier);\n                } else {\n                    this.setState(modifier);\n                }\n            }\n\n            /**\n             * This method is used by the internal raw Onyx `sendDataToConnection`, it is designed to prevent unnecessary renders while a component\n             * still in a \"loading\" (read \"mounting\") state. The temporary initial state is saved to the HOC instance and setState()\n             * only called once all the necessary data has been collected.\n             *\n             * There is however the possibility the component could have been updated by a call to setState()\n             * before the data was \"initially\" collected. A race condition.\n             * For example some update happened on some key, while onyx was still gathering the initial hydration data.\n             * This update is disptached directly to setStateProxy and therefore the component has the most up-to-date data\n             *\n             * This is a design flaw in Onyx itself as dispatching updates before initial hydration is not a correct event flow.\n             * We however need to workaround this issue in the HOC. The addition of initialValue makes things even more complex,\n             * since you cannot be really sure if the component has been updated before or after the initial hydration. Therefore if\n             * initialValue is there, we just check if the update is different than that and then try to handle it as best as we can.\n             *\n             * @param {String} statePropertyName\n             * @param {*} val\n             */\n            setWithOnyxState(statePropertyName, val) {\n                const prevValue = this.state[statePropertyName];\n\n                // If the component is not loading (read \"mounting\"), then we can just update the state\n                // There is a small race condition.\n                // When calling setWithOnyxState we delete the tempState object that is used to hold temporary state updates while the HOC is gathering data.\n                // However the loading flag is only set on the setState callback down below. setState however is an async operation that is also batched,\n                // therefore there is a small window of time where the loading flag is not false but the tempState is already gone\n                // (while the update is queued and waiting to be applied).\n                // This simply bypasses the loading check if the tempState is gone and the update can be safely queued with a normal setStateProxy.\n                if (!this.state.loading || !this.tempState) {\n                    // Performance optimization, do not trigger update with same values\n                    if (prevValue === val || utils.areObjectsEmpty(prevValue, val)) {\n                        return;\n                    }\n\n                    this.setStateProxy({[statePropertyName]: val});\n                    return;\n                }\n\n                this.tempState[statePropertyName] = val;\n\n                // If some key does not have a value yet, do not update the state yet\n                const tempStateIsMissingKey = _.some(requiredKeysForInit, (key) => _.isUndefined(this.tempState[key]));\n                if (tempStateIsMissingKey) {\n                    return;\n                }\n\n                const stateUpdate = {...this.tempState};\n                delete this.tempState;\n\n                // Full of hacky workarounds to prevent the race condition described above.\n                this.setState((prevState) => {\n                    const finalState = _.reduce(\n                        stateUpdate,\n                        (result, value, key) => {\n                            if (key === 'loading') {\n                                return result;\n                            }\n\n                            const initialValue = mapOnyxToState[key].initialValue;\n\n                            // If initialValue is there and the state contains something different it means\n                            // an update has already been received and we can discard the value we are trying to hydrate\n                            if (!_.isUndefined(initialValue) && !_.isUndefined(prevState[key]) && prevState[key] !== initialValue) {\n                                // eslint-disable-next-line no-param-reassign\n                                result[key] = prevState[key];\n\n                                // if value is already there (without initial value) then we can discard the value we are trying to hydrate\n                            } else if (!_.isUndefined(prevState[key])) {\n                                // eslint-disable-next-line no-param-reassign\n                                result[key] = prevState[key];\n                            } else {\n                                // eslint-disable-next-line no-param-reassign\n                                result[key] = value;\n                            }\n                            return result;\n                        },\n                        {},\n                    );\n\n                    finalState.loading = false;\n                    return finalState;\n                });\n            }\n\n            /**\n             * Makes sure each Onyx key we requested has been set to state with a value of some kind.\n             * We are doing this so that the wrapped component will only render when all the data\n             * it needs is available to it.\n             */\n            checkEvictableKeys() {\n                // We will add this key to our list of recently accessed keys\n                // if the canEvict function returns true. This is necessary criteria\n                // we MUST use to specify if a key can be removed or not.\n                _.each(mapOnyxToState, (mapping) => {\n                    if (_.isUndefined(mapping.canEvict)) {\n                        return;\n                    }\n\n                    const canEvict = Str.result(mapping.canEvict, this.props);\n                    const key = Str.result(mapping.key, this.props);\n\n                    if (!Onyx.isSafeEvictionKey(key)) {\n                        throw new Error(`canEvict can't be used on key '${key}'. This key must explicitly be flagged as safe for removal by adding it to Onyx.init({safeEvictionKeys: []}).`);\n                    }\n\n                    if (canEvict) {\n                        Onyx.removeFromEvictionBlockList(key, mapping.connectionID);\n                    } else {\n                        Onyx.addToEvictionBlockList(key, mapping.connectionID);\n                    }\n                });\n            }\n\n            /**\n             * Takes a single mapping and binds the state of the component to the store\n             *\n             * @param {object} mapping\n             * @param {string|function} mapping.key key to connect to. can be a string or a\n             * function that takes this.props as an argument and returns a string\n             * @param {string} statePropertyName the name of the state property that Onyx will add the data to\n             * @param {boolean} [mapping.initWithStoredValues] If set to false, then no data will be prefilled into the\n             *  component\n             * @param {string} key to connect to Onyx with\n             */\n            connectMappingToOnyx(mapping, statePropertyName, key) {\n                // Remember what the previous key was so that key changes can be detected when data is being loaded from Onyx. This will allow\n                // dependent keys to finish loading their data.\n                // eslint-disable-next-line no-param-reassign\n                mapOnyxToState[statePropertyName].previousKey = key;\n\n                // eslint-disable-next-line rulesdir/prefer-onyx-connect-in-libs\n                this.activeConnectionIDs[key] = Onyx.connect({\n                    ...mapping,\n                    key,\n                    statePropertyName,\n                    withOnyxInstance: this,\n                    displayName,\n                });\n            }\n\n            flushPendingSetStates() {\n                if (!this.shouldDelayUpdates) {\n                    return;\n                }\n\n                this.shouldDelayUpdates = false;\n\n                this.pendingSetStates.forEach((modifier) => {\n                    this.setState(modifier);\n                });\n                this.pendingSetStates = [];\n            }\n\n            render() {\n                // Remove any null values so that React replaces them with default props\n                const propsToPass = _.omit(this.props, _.isNull);\n\n                if (this.state.loading) {\n                    return null;\n                }\n\n                // Remove any internal state properties used by withOnyx\n                // that should not be passed to a wrapped component\n                let stateToPass = _.omit(this.state, 'loading');\n                stateToPass = _.omit(stateToPass, _.isNull);\n\n                // Spreading props and state is necessary in an HOC where the data cannot be predicted\n                return (\n                    <WrappedComponent\n                        markReadyForHydration={this.flushPendingSetStates}\n                        // eslint-disable-next-line react/jsx-props-no-spreading\n                        {...propsToPass}\n                        // eslint-disable-next-line react/jsx-props-no-spreading\n                        {...stateToPass}\n                        ref={this.props.forwardedRef}\n                    />\n                );\n            }\n        }\n\n        withOnyx.propTypes = {\n            forwardedRef: PropTypes.oneOfType([\n                PropTypes.func,\n                // eslint-disable-next-line react/forbid-prop-types\n                PropTypes.shape({current: PropTypes.object}),\n            ]),\n        };\n        withOnyx.defaultProps = {\n            forwardedRef: undefined,\n        };\n        withOnyx.displayName = `withOnyx(${displayName})`;\n        return React.forwardRef((props, ref) => {\n            const Component = withOnyx;\n            return (\n                <Component\n                    // eslint-disable-next-line react/jsx-props-no-spreading\n                    {...props}\n                    forwardedRef={ref}\n                />\n            );\n        });\n    };\n}\n","import Onyx from './Onyx';\nimport withOnyx from './withOnyx';\n\nexport default Onyx;\nexport {withOnyx};\n"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__746__","__WEBPACK_EXTERNAL_MODULE__952__","__WEBPACK_EXTERNAL_MODULE__111__","__WEBPACK_EXTERNAL_MODULE__802__","__WEBPACK_EXTERNAL_MODULE__407__","__WEBPACK_EXTERNAL_MODULE__156__","decorateWithMetrics","func","getMetrics","printMetrics","resetMetrics","ReactPropTypesSecret","emptyFunction","emptyFunctionWithReset","resetWarningCache","shim","props","propName","componentName","location","propFullName","secret","err","Error","name","getShim","isRequired","ReactPropTypes","array","bool","number","object","string","symbol","any","arrayOf","element","elementType","instanceOf","node","objectOf","oneOf","oneOfType","shape","exact","checkPropTypes","PropTypes","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","g","globalThis","this","Function","e","window","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","logger","logAlert","message","level","logInfo","isMergeableObject","val","toString","Array","isArray","fastMerge","target","source","shouldRemoveNullObjectValues","arguments","length","_","destination","targetKeys","keys","i","isSourceOrTargetNull","sourceKeys","shouldOmitSourceKey","isSourceKeyMergable","mergeObject","areObjectsEmpty","b","removeNestedNullValues","isDefined","constructor","storageKeys","Set","recentKeys","storageMap","pendingPromises","Map","getAllKeys","from","getValue","addToAccessedKeys","hasCacheForKey","addKey","add","set","drop","delete","merge","data","assign","utils","mergedKeys","hasPendingTask","taskName","getTaskPromise","captureTask","promise","returnPromise","finally","removeLeastRecentlyUsedKeys","numKeysToRemove","size","maxRecentKeysSize","iterator","values","temp","next","push","setRecentKeysLimit","limit","hasValueChanged","deepEqual","startsWith","haystack","needle","result","parameter","_len","args","_key","debugSetState","setShouldDebugSetState","debug","logSetStateCall","mapping","previousValue","newValue","caller","keyThatChanged","logParams","difference","changes","comparisonObject","lodashTransform","console","displayName","customStoreInstance","getCustomStore","createStore","provider","setItem","multiGet","keysParam","getMany","then","index","multiMerge","pairs","store","Promise","all","_ref","promisifyRequest","upsertMany","_ref2","prev","put","mergeItem","_changes","modifiedData","multiSet","setMany","clear","setMemoryOnlyKeys","getItem","removeItem","del","removeItems","delMany","getDatabaseSize","navigator","storage","estimate","bytesUsed","usage","bytesRemaining","quota","catch","error","SYNC_ONYX","raiseStorageSyncEvent","onyxKey","global","localStorage","Storage","keepInstancesSync","onStorageKeyChanged","raiseStorageSyncManyKeysEvent","onyxKeys","batchedChanges","allKeys","addEventListener","event","subscriptions","channel","BroadcastChannel","sendMessage","postMessage","subscribe","callback","onmessage","forEach","c","NEW_LEADER_MESSAGE","REMOVED_LEADER_MESSAGE","clientID","s4","Math","floor","random","substring","Str","subscribers","timestamp","activeClientID","setIsReady","isReadyPromise","resolve","isReady","isClientTheLeader","METHOD","SET","MERGE","MERGE_COLLECTION","MULTI_SET","CLEAR","ON_CLEAR","mergeQueue","mergeQueuePromise","lastConnectionID","callbackToStateMapping","onyxCollectionKeyMap","recentlyAccessedKeys","evictionAllowList","evictionBlocklist","defaultKeyStates","deferredInitTask","deferred","res","createDeferredTask","isClearing","onClearCallback","batchUpdatesPromise","batchUpdatesQueue","maybeFlushBatchUpdates","setTimeout","updatesCopy","unstable_batchedUpdates","applyUpdates","batchUpdates","updates","getSubsetOfData","sourceData","selector","withOnyxInstanceState","reduceCollectionWithSelector","collection","finalCollection","item","cache","Logger","storedKeys","isCollectionKey","has","isCollectionMemberKey","collectionKey","isKeyMatch","configKey","isSafeEvictionKey","testKey","removeLastAccessedKey","addLastAccessedKey","removeFromEvictionBlockList","connectionID","getCachedCollection","collectionMemberKeys","storedKey","curr","cachedValue","keysChanged","partialCollection","notifyRegularSubscibers","notifyWithOnyxSubscibers","stateMappingKeys","subscriber","isSubscribedToCollectionKey","isSubscribedToCollectionMemberKey","cachedCollection","waitForCollectionCallback","dataKeys","j","dataKey","withOnyxInstance","setStateProxy","prevState","previousData","statePropertyName","newData","state","PerformanceUtils","dataFromCollection","prevData","keyChanged","canUpdateSubscriber","prevDataWithNewData","newCollection","sendDataToConnection","matchedKey","isBatched","setWithOnyxState","getCollectionDataAndSendAsObject","matchingKeys","finalObject","scheduleSubscriberUpdate","scheduleNotifyCollectionSubscribers","remove","reportStorageQuota","dbSizeError","evictStorageAndRetry","onyxMethod","keyForRemoval","broadcastUpdate","method","hasChanged","wasRemoved","join","initWithStoredValues","hasPendingMergeForKey","Boolean","removeNullValues","ActiveClientManager","Broadcast","type","valueAfterRemoving","updatePromise","prepareKeyValuePairsForStorage","keyValuePairs","updatePromises","applyMerge","existingValue","lastChange","change","shouldOverwriteExistingValue","initializeWithDefaultKeyStates","asObject","merged","keysToPreserve","keysToBeClearedFromStorage","keyValuesToResetAsCollection","keyValuesToResetIndividually","isKeyToPreserve","isDefaultKey","oldValue","indexOf","defaultKeyValuePairs","mergeCollection","hasCollectionKeyCheckFailed","_data","persistedKeys","existingKeys","newKeys","pick","partition","includes","existingKeyCollection","keyValuePairsForExistingCollection","keyValuePairsForNewCollection","promises","promiseUpdate","update","_ref3","clearPromise","_ref4","p","Onyx","connect","canEvict","addKeyToRecentlyAccessedIfNeeded","endsWith","disconnect","keyToRemoveFromEvictionBlocklist","init","initialKeyStates","safeEvictionKeys","maxCachedKeysCount","captureMetrics","shouldSyncMultipleInstances","isTimestampEqual","isTimestampNewer","Date","now","_ref5","decorate","applyDecorators","collectionValues","COLLECTION","acc","safeEvictionKey","registerLogger","addToEvictionBlockList","keyList","Infinity","tryGetCachedValue","allCacheKeys","k","onClear","isClientManagerReady","subscribeToClientChange","mappingPropertiesToIgnoreChangesTo","getOnyxDataFromState","onyxToStateMapping","mapOnyxToState","shouldDelayUpdates","requiredKeysForInit","omit","config","WrappedComponent","component","withOnyx","React","super","bind","flushPendingSetStates","activeConnectionIDs","cachedState","resultObj","propertyName","initialValue","allowStaleData","loading","tempState","componentDidMount","onyxDataFromState","connectMappingToOnyx","checkEvictableKeys","componentDidUpdate","prevProps","isFirstTimeUpdatingAfterLoading","prevOnyxDataFromState","previousKey","newKey","componentWillUnmount","modifier","pendingSetStates","setState","prevValue","stateUpdate","finalState","render","propsToPass","stateToPass","_extends","markReadyForHydration","ref","forwardedRef","propTypes","current","defaultProps","Component"],"sourceRoot":""}