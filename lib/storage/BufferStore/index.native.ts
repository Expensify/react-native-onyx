/**
 * Native (iOS/Android) BufferStore implementation.
 *
 * This is a NitroModules HybridObject wrapping a thread-safe C++ buffer
 * protected by std::shared_mutex. The HybridObject provides shared memory
 * access between the main JS thread and the Worklet Worker Runtime:
 *
 * Main JS Thread:
 * - Onyx.set/merge -> WriteBuffer -> bufferStore.set() -> Nitro fromJSI (deep copy to AnyValue)
 * - C++ side acquires unique_lock, inserts entry, releases lock
 *
 * Worklet Worker Runtime:
 * - NativeFlushWorker calls bufferStore.drain()
 * - C++ side acquires unique_lock, atomically swaps out all entries, releases lock
 * - Nitro toJSI converts AnyValue back to JS objects (on worker thread)
 * - Worker does JSON.stringify + nitroSqlite.execute (on worker thread)
 *
 * When the NitroModules bridge is not available (e.g., in test environments),
 * falls back to a plain JS Map implementation.
 */

import type {NitroModules} from 'react-native-nitro-modules';
import type {OnyxKey} from '../../types';
import type {BufferEntry} from '../WriteBuffer';
import type BufferStoreType from './types';

/**
 * Creates a native BufferStore backed by a C++ NativeBufferStore HybridObject.
 *
 * The HybridObject is created via NitroModules.createHybridObject() and
 * wraps a std::shared_mutex-protected C++ unordered_map. The drain() method
 * atomically returns and clears all pending entries.
 *
 * When the NitroModules bridge is not available (e.g., in test environments),
 * falls back to a plain JS Map implementation.
 */
function createNativeBufferStore(): BufferStoreType {
    // Attempt to use the NitroModules HybridObject
    try {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const {NitroModules: NM} = require('react-native-nitro-modules') as {NitroModules: typeof NitroModules};

        // The HybridObject is generated by nitrogen codegen from the C++
        // NativeBufferStore class. It exposes the same interface as BufferStore.
        // We use `as unknown as BufferStoreType` because NM.createHybridObject
        // constrains T to HybridObject<{}>, but at runtime the object satisfies
        // BufferStoreType. The nitrogen-generated spec bridges the gap.
        const nativeStore = NM.createHybridObject<never>('NativeBufferStore') as unknown as BufferStoreType;

        return nativeStore;
    } catch {
        // NitroModules not available -- fall back to JS Map
        // This happens in test environments or when the native module isn't linked
        console.warn('[Onyx] NativeBufferStore not available, falling back to JS Map');

        const map = new Map<OnyxKey, BufferEntry>();
        return {
            get(key: OnyxKey): BufferEntry | undefined {
                return map.get(key);
            },
            set(key: OnyxKey, entry: BufferEntry): void {
                map.set(key, entry);
            },
            delete(key: OnyxKey): boolean {
                return map.delete(key);
            },
            has(key: OnyxKey): boolean {
                return map.has(key);
            },
            get size(): number {
                return map.size;
            },
            clear(): void {
                map.clear();
            },
            entries(): IterableIterator<[OnyxKey, BufferEntry]> {
                return map.entries();
            },
        };
    }
}

export default createNativeBufferStore;
